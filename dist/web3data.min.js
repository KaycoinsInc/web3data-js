(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.web3data = factory());
}(this, (function () { 'use strict';

  var bind = function bind(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      return fn.apply(thisArg, args);
    };
  };

  /*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */

  var isBuffer = function isBuffer (obj) {
    return obj != null && obj.constructor != null &&
      typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  };

  /*global toString:true*/

  // utils is a library of generic helper functions non-specific to axios

  var toString = Object.prototype.toString;

  /**
   * Determine if a value is an Array
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Array, otherwise false
   */
  function isArray(val) {
    return toString.call(val) === '[object Array]';
  }

  /**
   * Determine if a value is an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an ArrayBuffer, otherwise false
   */
  function isArrayBuffer(val) {
    return toString.call(val) === '[object ArrayBuffer]';
  }

  /**
   * Determine if a value is a FormData
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an FormData, otherwise false
   */
  function isFormData(val) {
    return (typeof FormData !== 'undefined') && (val instanceof FormData);
  }

  /**
   * Determine if a value is a view on an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
   */
  function isArrayBufferView(val) {
    var result;
    if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
      result = ArrayBuffer.isView(val);
    } else {
      result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
    }
    return result;
  }

  /**
   * Determine if a value is a String
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a String, otherwise false
   */
  function isString(val) {
    return typeof val === 'string';
  }

  /**
   * Determine if a value is a Number
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Number, otherwise false
   */
  function isNumber(val) {
    return typeof val === 'number';
  }

  /**
   * Determine if a value is undefined
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if the value is undefined, otherwise false
   */
  function isUndefined(val) {
    return typeof val === 'undefined';
  }

  /**
   * Determine if a value is an Object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Object, otherwise false
   */
  function isObject(val) {
    return val !== null && typeof val === 'object';
  }

  /**
   * Determine if a value is a Date
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Date, otherwise false
   */
  function isDate(val) {
    return toString.call(val) === '[object Date]';
  }

  /**
   * Determine if a value is a File
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a File, otherwise false
   */
  function isFile(val) {
    return toString.call(val) === '[object File]';
  }

  /**
   * Determine if a value is a Blob
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Blob, otherwise false
   */
  function isBlob(val) {
    return toString.call(val) === '[object Blob]';
  }

  /**
   * Determine if a value is a Function
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Function, otherwise false
   */
  function isFunction(val) {
    return toString.call(val) === '[object Function]';
  }

  /**
   * Determine if a value is a Stream
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Stream, otherwise false
   */
  function isStream(val) {
    return isObject(val) && isFunction(val.pipe);
  }

  /**
   * Determine if a value is a URLSearchParams object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a URLSearchParams object, otherwise false
   */
  function isURLSearchParams(val) {
    return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
  }

  /**
   * Trim excess whitespace off the beginning and end of a string
   *
   * @param {String} str The String to trim
   * @returns {String} The String freed of excess whitespace
   */
  function trim(str) {
    return str.replace(/^\s*/, '').replace(/\s*$/, '');
  }

  /**
   * Determine if we're running in a standard browser environment
   *
   * This allows axios to run in a web worker, and react-native.
   * Both environments support XMLHttpRequest, but not fully standard globals.
   *
   * web workers:
   *  typeof window -> undefined
   *  typeof document -> undefined
   *
   * react-native:
   *  navigator.product -> 'ReactNative'
   * nativescript
   *  navigator.product -> 'NativeScript' or 'NS'
   */
  function isStandardBrowserEnv() {
    if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                             navigator.product === 'NativeScript' ||
                                             navigator.product === 'NS')) {
      return false;
    }
    return (
      typeof window !== 'undefined' &&
      typeof document !== 'undefined'
    );
  }

  /**
   * Iterate over an Array or an Object invoking a function for each item.
   *
   * If `obj` is an Array callback will be called passing
   * the value, index, and complete array for each item.
   *
   * If 'obj' is an Object callback will be called passing
   * the value, key, and complete object for each property.
   *
   * @param {Object|Array} obj The object to iterate
   * @param {Function} fn The callback to invoke for each item
   */
  function forEach(obj, fn) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === 'undefined') {
      return;
    }

    // Force an array if not already something iterable
    if (typeof obj !== 'object') {
      /*eslint no-param-reassign:0*/
      obj = [obj];
    }

    if (isArray(obj)) {
      // Iterate over array values
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      // Iterate over object keys
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }

  /**
   * Accepts varargs expecting each argument to be an object, then
   * immutably merges the properties of each object and returns result.
   *
   * When multiple objects contain the same key the later object in
   * the arguments list will take precedence.
   *
   * Example:
   *
   * ```js
   * var result = merge({foo: 123}, {foo: 456});
   * console.log(result.foo); // outputs 456
   * ```
   *
   * @param {Object} obj1 Object to merge
   * @returns {Object} Result of all merge properties
   */
  function merge(/* obj1, obj2, obj3, ... */) {
    var result = {};
    function assignValue(val, key) {
      if (typeof result[key] === 'object' && typeof val === 'object') {
        result[key] = merge(result[key], val);
      } else {
        result[key] = val;
      }
    }

    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }
    return result;
  }

  /**
   * Function equal to merge with the difference being that no reference
   * to original objects is kept.
   *
   * @see merge
   * @param {Object} obj1 Object to merge
   * @returns {Object} Result of all merge properties
   */
  function deepMerge(/* obj1, obj2, obj3, ... */) {
    var result = {};
    function assignValue(val, key) {
      if (typeof result[key] === 'object' && typeof val === 'object') {
        result[key] = deepMerge(result[key], val);
      } else if (typeof val === 'object') {
        result[key] = deepMerge({}, val);
      } else {
        result[key] = val;
      }
    }

    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }
    return result;
  }

  /**
   * Extends object a by mutably adding to it the properties of object b.
   *
   * @param {Object} a The object to be extended
   * @param {Object} b The object to copy properties from
   * @param {Object} thisArg The object to bind function to
   * @return {Object} The resulting value of object a
   */
  function extend(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
      if (thisArg && typeof val === 'function') {
        a[key] = bind(val, thisArg);
      } else {
        a[key] = val;
      }
    });
    return a;
  }

  var utils = {
    isArray: isArray,
    isArrayBuffer: isArrayBuffer,
    isBuffer: isBuffer,
    isFormData: isFormData,
    isArrayBufferView: isArrayBufferView,
    isString: isString,
    isNumber: isNumber,
    isObject: isObject,
    isUndefined: isUndefined,
    isDate: isDate,
    isFile: isFile,
    isBlob: isBlob,
    isFunction: isFunction,
    isStream: isStream,
    isURLSearchParams: isURLSearchParams,
    isStandardBrowserEnv: isStandardBrowserEnv,
    forEach: forEach,
    merge: merge,
    deepMerge: deepMerge,
    extend: extend,
    trim: trim
  };

  function encode(val) {
    return encodeURIComponent(val).
      replace(/%40/gi, '@').
      replace(/%3A/gi, ':').
      replace(/%24/g, '$').
      replace(/%2C/gi, ',').
      replace(/%20/g, '+').
      replace(/%5B/gi, '[').
      replace(/%5D/gi, ']');
  }

  /**
   * Build a URL by appending params to the end
   *
   * @param {string} url The base of the url (e.g., http://www.google.com)
   * @param {object} [params] The params to be appended
   * @returns {string} The formatted url
   */
  var buildURL = function buildURL(url, params, paramsSerializer) {
    /*eslint no-param-reassign:0*/
    if (!params) {
      return url;
    }

    var serializedParams;
    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];

      utils.forEach(params, function serialize(val, key) {
        if (val === null || typeof val === 'undefined') {
          return;
        }

        if (utils.isArray(val)) {
          key = key + '[]';
        } else {
          val = [val];
        }

        utils.forEach(val, function parseValue(v) {
          if (utils.isDate(v)) {
            v = v.toISOString();
          } else if (utils.isObject(v)) {
            v = JSON.stringify(v);
          }
          parts.push(encode(key) + '=' + encode(v));
        });
      });

      serializedParams = parts.join('&');
    }

    if (serializedParams) {
      var hashmarkIndex = url.indexOf('#');
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }

      url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
    }

    return url;
  };

  function InterceptorManager() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  InterceptorManager.prototype.use = function use(fulfilled, rejected) {
    this.handlers.push({
      fulfilled: fulfilled,
      rejected: rejected
    });
    return this.handlers.length - 1;
  };

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   */
  InterceptorManager.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   */
  InterceptorManager.prototype.forEach = function forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  };

  var InterceptorManager_1 = InterceptorManager;

  /**
   * Transform the data for a request or a response
   *
   * @param {Object|String} data The data to be transformed
   * @param {Array} headers The headers for the request or response
   * @param {Array|Function} fns A single function or Array of functions
   * @returns {*} The resulting transformed data
   */
  var transformData = function transformData(data, headers, fns) {
    /*eslint no-param-reassign:0*/
    utils.forEach(fns, function transform(fn) {
      data = fn(data, headers);
    });

    return data;
  };

  var isCancel = function isCancel(value) {
    return !!(value && value.__CANCEL__);
  };

  var global$1 = (typeof global !== "undefined" ? global :
              typeof self !== "undefined" ? self :
              typeof window !== "undefined" ? window : {});

  // shim for using process in browser
  // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

  function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
  }
  function defaultClearTimeout () {
      throw new Error('clearTimeout has not been defined');
  }
  var cachedSetTimeout = defaultSetTimout;
  var cachedClearTimeout = defaultClearTimeout;
  if (typeof global$1.setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
  }
  if (typeof global$1.clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
  }

  function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
      }
      // if setTimeout wasn't available but was latter defined
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
      } catch(e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
          } catch(e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
          }
      }


  }
  function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
      }
      // if clearTimeout wasn't available but was latter defined
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
      } catch (e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
          } catch (e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
          }
      }



  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;

  function cleanUpNextTick() {
      if (!draining || !currentQueue) {
          return;
      }
      draining = false;
      if (currentQueue.length) {
          queue = currentQueue.concat(queue);
      } else {
          queueIndex = -1;
      }
      if (queue.length) {
          drainQueue();
      }
  }

  function drainQueue() {
      if (draining) {
          return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;

      var len = queue.length;
      while(len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
              if (currentQueue) {
                  currentQueue[queueIndex].run();
              }
          }
          queueIndex = -1;
          len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
  }
  function nextTick(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
          }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
      }
  }
  // v8 likes predictible objects
  function Item(fun, array) {
      this.fun = fun;
      this.array = array;
  }
  Item.prototype.run = function () {
      this.fun.apply(null, this.array);
  };
  var title = 'browser';
  var platform = 'browser';
  var browser = true;
  var env = {};
  var argv = [];
  var version = ''; // empty string to avoid regexp issues
  var versions = {};
  var release = {};
  var config = {};

  function noop() {}

  var on = noop;
  var addListener = noop;
  var once = noop;
  var off = noop;
  var removeListener = noop;
  var removeAllListeners = noop;
  var emit = noop;

  function binding(name) {
      throw new Error('process.binding is not supported');
  }

  function cwd () { return '/' }
  function chdir (dir) {
      throw new Error('process.chdir is not supported');
  }function umask() { return 0; }

  // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
  var performance = global$1.performance || {};
  var performanceNow =
    performance.now        ||
    performance.mozNow     ||
    performance.msNow      ||
    performance.oNow       ||
    performance.webkitNow  ||
    function(){ return (new Date()).getTime() };

  // generate timestamp or delta
  // see http://nodejs.org/api/process.html#process_process_hrtime
  function hrtime(previousTimestamp){
    var clocktime = performanceNow.call(performance)*1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor((clocktime%1)*1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds<0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds,nanoseconds]
  }

  var startTime = new Date();
  function uptime() {
    var currentTime = new Date();
    var dif = currentTime - startTime;
    return dif / 1000;
  }

  var process = {
    nextTick: nextTick,
    title: title,
    browser: browser,
    env: env,
    argv: argv,
    version: version,
    versions: versions,
    on: on,
    addListener: addListener,
    once: once,
    off: off,
    removeListener: removeListener,
    removeAllListeners: removeAllListeners,
    emit: emit,
    binding: binding,
    cwd: cwd,
    chdir: chdir,
    umask: umask,
    hrtime: hrtime,
    platform: platform,
    release: release,
    config: config,
    uptime: uptime
  };

  var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
    utils.forEach(headers, function processHeader(value, name) {
      if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name];
      }
    });
  };

  /**
   * Update an Error with the specified config, error code, and response.
   *
   * @param {Error} error The error to update.
   * @param {Object} config The config.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   * @returns {Error} The error.
   */
  var enhanceError = function enhanceError(error, config, code, request, response) {
    error.config = config;
    if (code) {
      error.code = code;
    }

    error.request = request;
    error.response = response;
    error.isAxiosError = true;

    error.toJSON = function() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: this.config,
        code: this.code
      };
    };
    return error;
  };

  /**
   * Create an Error with the specified message, config, error code, request and response.
   *
   * @param {string} message The error message.
   * @param {Object} config The config.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   * @returns {Error} The created error.
   */
  var createError = function createError(message, config, code, request, response) {
    var error = new Error(message);
    return enhanceError(error, config, code, request, response);
  };

  /**
   * Resolve or reject a Promise based on response status.
   *
   * @param {Function} resolve A function that resolves the promise.
   * @param {Function} reject A function that rejects the promise.
   * @param {object} response The response.
   */
  var settle = function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;
    if (!validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(createError(
        'Request failed with status code ' + response.status,
        response.config,
        null,
        response.request,
        response
      ));
    }
  };

  // Headers whose duplicates are ignored by node
  // c.f. https://nodejs.org/api/http.html#http_message_headers
  var ignoreDuplicateOf = [
    'age', 'authorization', 'content-length', 'content-type', 'etag',
    'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
    'last-modified', 'location', 'max-forwards', 'proxy-authorization',
    'referer', 'retry-after', 'user-agent'
  ];

  /**
   * Parse headers into an object
   *
   * ```
   * Date: Wed, 27 Aug 2014 08:58:49 GMT
   * Content-Type: application/json
   * Connection: keep-alive
   * Transfer-Encoding: chunked
   * ```
   *
   * @param {String} headers Headers needing to be parsed
   * @returns {Object} Headers parsed into an object
   */
  var parseHeaders = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;

    if (!headers) { return parsed; }

    utils.forEach(headers.split('\n'), function parser(line) {
      i = line.indexOf(':');
      key = utils.trim(line.substr(0, i)).toLowerCase();
      val = utils.trim(line.substr(i + 1));

      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === 'set-cookie') {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
        }
      }
    });

    return parsed;
  };

  var isURLSameOrigin = (
    utils.isStandardBrowserEnv() ?

    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
      (function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement('a');
        var originURL;

        /**
      * Parse a URL to discover it's components
      *
      * @param {String} url The URL to be parsed
      * @returns {Object}
      */
        function resolveURL(url) {
          var href = url;

          if (msie) {
          // IE needs attribute set twice to normalize properties
            urlParsingNode.setAttribute('href', href);
            href = urlParsingNode.href;
          }

          urlParsingNode.setAttribute('href', href);

          // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
              urlParsingNode.pathname :
              '/' + urlParsingNode.pathname
          };
        }

        originURL = resolveURL(window.location.href);

        /**
      * Determine if a URL shares the same origin as the current location
      *
      * @param {String} requestURL The URL to test
      * @returns {boolean} True if URL shares the same origin, otherwise false
      */
        return function isURLSameOrigin(requestURL) {
          var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
          return (parsed.protocol === originURL.protocol &&
              parsed.host === originURL.host);
        };
      })() :

    // Non standard browser envs (web workers, react-native) lack needed support.
      (function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      })()
  );

  var cookies = (
    utils.isStandardBrowserEnv() ?

    // Standard browser envs support document.cookie
      (function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + '=' + encodeURIComponent(value));

            if (utils.isNumber(expires)) {
              cookie.push('expires=' + new Date(expires).toGMTString());
            }

            if (utils.isString(path)) {
              cookie.push('path=' + path);
            }

            if (utils.isString(domain)) {
              cookie.push('domain=' + domain);
            }

            if (secure === true) {
              cookie.push('secure');
            }

            document.cookie = cookie.join('; ');
          },

          read: function read(name) {
            var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
            return (match ? decodeURIComponent(match[3]) : null);
          },

          remove: function remove(name) {
            this.write(name, '', Date.now() - 86400000);
          }
        };
      })() :

    // Non standard browser env (web workers, react-native) lack needed support.
      (function nonStandardBrowserEnv() {
        return {
          write: function write() {},
          read: function read() { return null; },
          remove: function remove() {}
        };
      })()
  );

  var xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;

      if (utils.isFormData(requestData)) {
        delete requestHeaders['Content-Type']; // Let the browser set it
      }

      var request = new XMLHttpRequest();

      // HTTP basic authentication
      if (config.auth) {
        var username = config.auth.username || '';
        var password = config.auth.password || '';
        requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
      }

      request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

      // Set the request timeout in MS
      request.timeout = config.timeout;

      // Listen for ready state
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }

        // Prepare the response
        var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
        var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
        var response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config: config,
          request: request
        };

        settle(resolve, reject, response);

        // Clean up request
        request = null;
      };

      // Handle browser request cancellation (as opposed to a manual cancellation)
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }

        reject(createError('Request aborted', config, 'ECONNABORTED', request));

        // Clean up request
        request = null;
      };

      // Handle low level network errors
      request.onerror = function handleError() {
        // Real errors are hidden from us by the browser
        // onerror should only fire if it's a network error
        reject(createError('Network Error', config, null, request));

        // Clean up request
        request = null;
      };

      // Handle timeout
      request.ontimeout = function handleTimeout() {
        reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
          request));

        // Clean up request
        request = null;
      };

      // Add xsrf header
      // This is only done if running in a standard browser environment.
      // Specifically not if we're in a web worker, or react-native.
      if (utils.isStandardBrowserEnv()) {
        var cookies$1 = cookies;

        // Add xsrf header
        var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
          cookies$1.read(config.xsrfCookieName) :
          undefined;

        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }

      // Add headers to the request
      if ('setRequestHeader' in request) {
        utils.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
            // Remove Content-Type if data is undefined
            delete requestHeaders[key];
          } else {
            // Otherwise add header to the request
            request.setRequestHeader(key, val);
          }
        });
      }

      // Add withCredentials to request if needed
      if (config.withCredentials) {
        request.withCredentials = true;
      }

      // Add responseType to request if needed
      if (config.responseType) {
        try {
          request.responseType = config.responseType;
        } catch (e) {
          // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
          // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
          if (config.responseType !== 'json') {
            throw e;
          }
        }
      }

      // Handle progress if needed
      if (typeof config.onDownloadProgress === 'function') {
        request.addEventListener('progress', config.onDownloadProgress);
      }

      // Not all browsers support upload events
      if (typeof config.onUploadProgress === 'function' && request.upload) {
        request.upload.addEventListener('progress', config.onUploadProgress);
      }

      if (config.cancelToken) {
        // Handle cancellation
        config.cancelToken.promise.then(function onCanceled(cancel) {
          if (!request) {
            return;
          }

          request.abort();
          reject(cancel);
          // Clean up request
          request = null;
        });
      }

      if (requestData === undefined) {
        requestData = null;
      }

      // Send the request
      request.send(requestData);
    });
  };

  var DEFAULT_CONTENT_TYPE = {
    'Content-Type': 'application/x-www-form-urlencoded'
  };

  function setContentTypeIfUnset(headers, value) {
    if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
      headers['Content-Type'] = value;
    }
  }

  function getDefaultAdapter() {
    var adapter;
    // Only Node.JS has a process variable that is of [[Class]] process
    if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
      // For node use HTTP adapter
      adapter = xhr;
    } else if (typeof XMLHttpRequest !== 'undefined') {
      // For browsers use XHR adapter
      adapter = xhr;
    }
    return adapter;
  }

  var defaults = {
    adapter: getDefaultAdapter(),

    transformRequest: [function transformRequest(data, headers) {
      normalizeHeaderName(headers, 'Accept');
      normalizeHeaderName(headers, 'Content-Type');
      if (utils.isFormData(data) ||
        utils.isArrayBuffer(data) ||
        utils.isBuffer(data) ||
        utils.isStream(data) ||
        utils.isFile(data) ||
        utils.isBlob(data)
      ) {
        return data;
      }
      if (utils.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils.isURLSearchParams(data)) {
        setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
        return data.toString();
      }
      if (utils.isObject(data)) {
        setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
        return JSON.stringify(data);
      }
      return data;
    }],

    transformResponse: [function transformResponse(data) {
      /*eslint no-param-reassign:0*/
      if (typeof data === 'string') {
        try {
          data = JSON.parse(data);
        } catch (e) { /* Ignore */ }
      }
      return data;
    }],

    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,

    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',

    maxContentLength: -1,

    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    }
  };

  defaults.headers = {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  };

  utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
    defaults.headers[method] = {};
  });

  utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
  });

  var defaults_1 = defaults;

  /**
   * Determines whether the specified URL is absolute
   *
   * @param {string} url The URL to test
   * @returns {boolean} True if the specified URL is absolute, otherwise false
   */
  var isAbsoluteURL = function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
  };

  /**
   * Creates a new URL by combining the specified URLs
   *
   * @param {string} baseURL The base URL
   * @param {string} relativeURL The relative URL
   * @returns {string} The combined URL
   */
  var combineURLs = function combineURLs(baseURL, relativeURL) {
    return relativeURL
      ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
      : baseURL;
  };

  /**
   * Throws a `Cancel` if cancellation has been requested.
   */
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
  }

  /**
   * Dispatch a request to the server using the configured adapter.
   *
   * @param {object} config The config that is to be used for the request
   * @returns {Promise} The Promise to be fulfilled
   */
  var dispatchRequest = function dispatchRequest(config) {
    throwIfCancellationRequested(config);

    // Support baseURL config
    if (config.baseURL && !isAbsoluteURL(config.url)) {
      config.url = combineURLs(config.baseURL, config.url);
    }

    // Ensure headers exist
    config.headers = config.headers || {};

    // Transform request data
    config.data = transformData(
      config.data,
      config.headers,
      config.transformRequest
    );

    // Flatten headers
    config.headers = utils.merge(
      config.headers.common || {},
      config.headers[config.method] || {},
      config.headers || {}
    );

    utils.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      function cleanHeaderConfig(method) {
        delete config.headers[method];
      }
    );

    var adapter = config.adapter || defaults_1.adapter;

    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);

      // Transform response data
      response.data = transformData(
        response.data,
        response.headers,
        config.transformResponse
      );

      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);

        // Transform response data
        if (reason && reason.response) {
          reason.response.data = transformData(
            reason.response.data,
            reason.response.headers,
            config.transformResponse
          );
        }
      }

      return Promise.reject(reason);
    });
  };

  /**
   * Config-specific merge-function which creates a new config-object
   * by merging two configuration objects together.
   *
   * @param {Object} config1
   * @param {Object} config2
   * @returns {Object} New object resulting from merging config2 to config1
   */
  var mergeConfig = function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    var config = {};

    utils.forEach(['url', 'method', 'params', 'data'], function valueFromConfig2(prop) {
      if (typeof config2[prop] !== 'undefined') {
        config[prop] = config2[prop];
      }
    });

    utils.forEach(['headers', 'auth', 'proxy'], function mergeDeepProperties(prop) {
      if (utils.isObject(config2[prop])) {
        config[prop] = utils.deepMerge(config1[prop], config2[prop]);
      } else if (typeof config2[prop] !== 'undefined') {
        config[prop] = config2[prop];
      } else if (utils.isObject(config1[prop])) {
        config[prop] = utils.deepMerge(config1[prop]);
      } else if (typeof config1[prop] !== 'undefined') {
        config[prop] = config1[prop];
      }
    });

    utils.forEach([
      'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
      'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
      'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'maxContentLength',
      'validateStatus', 'maxRedirects', 'httpAgent', 'httpsAgent', 'cancelToken',
      'socketPath'
    ], function defaultToConfig2(prop) {
      if (typeof config2[prop] !== 'undefined') {
        config[prop] = config2[prop];
      } else if (typeof config1[prop] !== 'undefined') {
        config[prop] = config1[prop];
      }
    });

    return config;
  };

  /**
   * Create a new instance of Axios
   *
   * @param {Object} instanceConfig The default config for the instance
   */
  function Axios(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_1(),
      response: new InterceptorManager_1()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {Object} config The config specific for this request (merged with this.defaults)
   */
  Axios.prototype.request = function request(config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof config === 'string') {
      config = arguments[1] || {};
      config.url = arguments[0];
    } else {
      config = config || {};
    }

    config = mergeConfig(this.defaults, config);
    config.method = config.method ? config.method.toLowerCase() : 'get';

    // Hook up interceptors middleware
    var chain = [dispatchRequest, undefined];
    var promise = Promise.resolve(config);

    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      chain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      chain.push(interceptor.fulfilled, interceptor.rejected);
    });

    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  };

  Axios.prototype.getUri = function getUri(config) {
    config = mergeConfig(this.defaults, config);
    return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
  };

  // Provide aliases for supported request methods
  utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
    /*eslint func-names:0*/
    Axios.prototype[method] = function(url, config) {
      return this.request(utils.merge(config || {}, {
        method: method,
        url: url
      }));
    };
  });

  utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    /*eslint func-names:0*/
    Axios.prototype[method] = function(url, data, config) {
      return this.request(utils.merge(config || {}, {
        method: method,
        url: url,
        data: data
      }));
    };
  });

  var Axios_1 = Axios;

  /**
   * A `Cancel` is an object that is thrown when an operation is canceled.
   *
   * @class
   * @param {string=} message The message.
   */
  function Cancel(message) {
    this.message = message;
  }

  Cancel.prototype.toString = function toString() {
    return 'Cancel' + (this.message ? ': ' + this.message : '');
  };

  Cancel.prototype.__CANCEL__ = true;

  var Cancel_1 = Cancel;

  /**
   * A `CancelToken` is an object that can be used to request cancellation of an operation.
   *
   * @class
   * @param {Function} executor The executor function.
   */
  function CancelToken(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    var token = this;
    executor(function cancel(message) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new Cancel_1(message);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `Cancel` if cancellation has been requested.
   */
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token: token,
      cancel: cancel
    };
  };

  var CancelToken_1 = CancelToken;

  /**
   * Syntactic sugar for invoking a function and expanding an array for arguments.
   *
   * Common use case would be to use `Function.prototype.apply`.
   *
   *  ```js
   *  function f(x, y, z) {}
   *  var args = [1, 2, 3];
   *  f.apply(null, args);
   *  ```
   *
   * With `spread` this example can be re-written.
   *
   *  ```js
   *  spread(function(x, y, z) {})([1, 2, 3]);
   *  ```
   *
   * @param {Function} callback
   * @returns {Function}
   */
  var spread = function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };

  /**
   * Create an instance of Axios
   *
   * @param {Object} defaultConfig The default config for the instance
   * @return {Axios} A new instance of Axios
   */
  function createInstance(defaultConfig) {
    var context = new Axios_1(defaultConfig);
    var instance = bind(Axios_1.prototype.request, context);

    // Copy axios.prototype to instance
    utils.extend(instance, Axios_1.prototype, context);

    // Copy context to instance
    utils.extend(instance, context);

    return instance;
  }

  // Create the default instance to be exported
  var axios = createInstance(defaults_1);

  // Expose Axios class to allow class inheritance
  axios.Axios = Axios_1;

  // Factory for creating new instances
  axios.create = function create(instanceConfig) {
    return createInstance(mergeConfig(axios.defaults, instanceConfig));
  };

  // Expose Cancel & CancelToken
  axios.Cancel = Cancel_1;
  axios.CancelToken = CancelToken_1;
  axios.isCancel = isCancel;

  // Expose all/spread
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;

  var axios_1 = axios;

  // Allow use of default import syntax in TypeScript
  var default_1 = axios;
  axios_1.default = default_1;

  var axios$1 = axios_1;

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var constants = createCommonjsModule(function (module) {
  module.exports.DEFAULT_WEBSOCKET_URL = 'wss://ws.web3api.io';
  module.exports.DEFAULT_BASE_URL = 'https://web3api.io/api/v2';
  module.exports.DEFAULT_RPC_URL = 'https://rpc.web3api.io';

  module.exports.API_KEY_HEADER = 'x-api-key';
  module.exports.BLOCKCHAIN_ID_HEADER = 'x-amberdata-blockchain-id';

  module.exports.BLOCKCHAIN_ID_ETHEREUM_MAINNET = '1c9c969065fcd1cf';
  module.exports.BLOCKCHAIN_ID_ETHEREUM_RINKEBY = '1b3f7a72b3e99c13';
  module.exports.BLOCKCHAIN_ID_BITCOIN = '408fa195a34b533de9ad9889f076045e';
  module.exports.BLOCKCHAIN_ID_BITCOIN_CASH = '43b45e71cc0615b491cb699e7071fc06';
  module.exports.BLOCKCHAIN_ID_BITCOIN_SV = 'a818635d36dbe125e26167c4438e2217';
  module.exports.BLOCKCHAIN_ID_LITECOIN = 'f94be61fd9f4fa684f992ddfd4e92272';
  module.exports.BLOCKCHAIN_ID_RIPPLE = '2b8a5d8975e8c2a2ed92450450979a3c';
  module.exports.BLOCKCHAIN_ID_ZCASH = 'b7d4f994f33c709be4ce6cbae31d7b8e';

  /* Endpoints */
  module.exports.ADDRESSES_ENDPOINT = '/addresses';
  module.exports.TOKENS_ENDPOINT = '/tokens';
  module.exports.TRANSACTIONS_ENDPOINT = '/transactions';
  module.exports.BLOCKS_ENDPOINT = '/blocks';
  module.exports.CONTRACTS_ENDPOINT = '/contracts';
  module.exports.SIGNATURES_ENDPOINT = '/signatures';
  module.exports.MARKET_ENDPOINT = '/market';

  module.exports.MARKET_FEATURES = [
    'pairs',
    'exchanges',
    'ohlcv',
    'prices',
    'tickers'
  ];

  /* Error messages */
  module.exports.ERROR_MESSAGE_TOKEN_NO_ADDRESS = 'No token address supplied';
  module.exports.ERROR_MESSAGE_TOKEN_NO_HOLDER_ADDRESS =
    'No token holder address supplied';
  module.exports.ERROR_MESSAGE_TRANSACTION_NO_HASH =
    'No transaction hash supplied';
  module.exports.ERROR_MESSAGE_ADDRESS_NO_ADDRESS = 'No address supplied';
  module.exports.ERROR_MESSAGE_CONTRACT_NO_ADDRESS =
    'No contract address supplied';
  module.exports.ERROR_MESSAGE_BLOCK_NO_ID = 'No block number or hash supplied';
  module.exports.ERROR_MESSAGE_MARKET_NO_PAIR = 'No market pair supplied';
  module.exports.ERROR_MESSAGE_MARKET_NO_FEATURE = `Missing or unknown. Features: '${module.exports.MARKET_FEATURES.join(
  "', '"
)}'`;
  module.exports.ERROR_MESSAGE_SIGNATURE_NO_HASH = 'No signature hash supplied';
  module.exports.ERROR_RPC_NO_METHOD = 'No RPC method provided';

  /* Ethereum based methods */
  module.exports.ETH_METHODS = {
    getBlockNumber: 'block',
    getBlock: 'block',
    getBlockTransactionCount: 'block',
    getUncle: 'block',
    getCode: 'contract',
    getGasPrice: 'transaction',
    getTransactionFromBlock: 'block',
    getTransactions: 'block',
    getTransaction: 'transaction',
    getPendingTransactions: 'transaction',
    getEtherPrice: 'market'
  };

  module.exports.BTC_METHODS = {
    address: [
      'getAllAddresses',
      'getInformation',
      'getMetadata',
      'getTransactions',
      'getPendingTransactions',
      'getBalance',
      'getLatestBalance',
      'getHistoricalBalance',
      'getMultipleBalances',
      'getBalancesBatch',
      'getMetrics'
    ],
    block: [
      'getBlocks',
      'getBlock',
      'getBlockNumber',
      'getTransactions',
      'getTransactionFromBlock',
      'getMetrics'
    ],
    transaction: ['getTransactions', 'getTransaction', 'getPendingTransactions']
  };

  module.exports.LTC_METHODS = {
    address: [
      'getAllAddresses',
      'getInformation',
      'getMetadata',
      'getTransactions',
      'getPendingTransactions',
      'getBalance',
      'getLatestBalance',
      'getHistoricalBalance',
      'getMultipleBalances',
      'getBalancesBatch',
      'getMetrics'
    ],
    block: [
      'getBlocks',
      'getBlock',
      'getBlockNumber',
      'getTransactions',
      'getTransactionFromBlock',
      'getMetrics'
    ],
    transaction: ['getTransactions', 'getTransaction', 'getPendingTransactions']
  };

  /* HTTP Response codes */
  module.exports.HTTP_CODE_NOT_FOUND = 404;
  });
  var constants_1 = constants.DEFAULT_WEBSOCKET_URL;
  var constants_2 = constants.DEFAULT_BASE_URL;
  var constants_3 = constants.DEFAULT_RPC_URL;
  var constants_4 = constants.API_KEY_HEADER;
  var constants_5 = constants.BLOCKCHAIN_ID_HEADER;
  var constants_6 = constants.BLOCKCHAIN_ID_ETHEREUM_MAINNET;
  var constants_7 = constants.BLOCKCHAIN_ID_ETHEREUM_RINKEBY;
  var constants_8 = constants.BLOCKCHAIN_ID_BITCOIN;
  var constants_9 = constants.BLOCKCHAIN_ID_BITCOIN_CASH;
  var constants_10 = constants.BLOCKCHAIN_ID_BITCOIN_SV;
  var constants_11 = constants.BLOCKCHAIN_ID_LITECOIN;
  var constants_12 = constants.BLOCKCHAIN_ID_RIPPLE;
  var constants_13 = constants.BLOCKCHAIN_ID_ZCASH;
  var constants_14 = constants.ADDRESSES_ENDPOINT;
  var constants_15 = constants.TOKENS_ENDPOINT;
  var constants_16 = constants.TRANSACTIONS_ENDPOINT;
  var constants_17 = constants.BLOCKS_ENDPOINT;
  var constants_18 = constants.CONTRACTS_ENDPOINT;
  var constants_19 = constants.SIGNATURES_ENDPOINT;
  var constants_20 = constants.MARKET_ENDPOINT;
  var constants_21 = constants.MARKET_FEATURES;
  var constants_22 = constants.ERROR_MESSAGE_TOKEN_NO_ADDRESS;
  var constants_23 = constants.ERROR_MESSAGE_TOKEN_NO_HOLDER_ADDRESS;
  var constants_24 = constants.ERROR_MESSAGE_TRANSACTION_NO_HASH;
  var constants_25 = constants.ERROR_MESSAGE_ADDRESS_NO_ADDRESS;
  var constants_26 = constants.ERROR_MESSAGE_CONTRACT_NO_ADDRESS;
  var constants_27 = constants.ERROR_MESSAGE_BLOCK_NO_ID;
  var constants_28 = constants.ERROR_MESSAGE_MARKET_NO_PAIR;
  var constants_29 = constants.ERROR_MESSAGE_MARKET_NO_FEATURE;
  var constants_30 = constants.ERROR_MESSAGE_SIGNATURE_NO_HASH;
  var constants_31 = constants.ERROR_RPC_NO_METHOD;
  var constants_32 = constants.ETH_METHODS;
  var constants_33 = constants.BTC_METHODS;
  var constants_34 = constants.LTC_METHODS;
  var constants_35 = constants.HTTP_CODE_NOT_FOUND;

  /**
   * Convert array of 16 byte values to UUID string format of the form:
   * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
   */
  var byteToHex = [];
  for (var i = 0; i < 256; ++i) {
    byteToHex[i] = (i + 0x100).toString(16).substr(1);
  }

  function bytesToUuid(buf, offset) {
    var i = offset || 0;
    var bth = byteToHex;
    // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
    return ([bth[buf[i++]], bth[buf[i++]], 
  	bth[buf[i++]], bth[buf[i++]], '-',
  	bth[buf[i++]], bth[buf[i++]], '-',
  	bth[buf[i++]], bth[buf[i++]], '-',
  	bth[buf[i++]], bth[buf[i++]], '-',
  	bth[buf[i++]], bth[buf[i++]],
  	bth[buf[i++]], bth[buf[i++]],
  	bth[buf[i++]], bth[buf[i++]]]).join('');
  }

  var bytesToUuid_1 = bytesToUuid;

  function uuidToBytes(uuid) {
    // Note: We assume we're being passed a valid uuid string
    var bytes = [];
    uuid.replace(/[a-fA-F0-9]{2}/g, function(hex) {
      bytes.push(parseInt(hex, 16));
    });

    return bytes;
  }

  function stringToBytes(str) {
    str = unescape(encodeURIComponent(str)); // UTF8 escape
    var bytes = new Array(str.length);
    for (var i = 0; i < str.length; i++) {
      bytes[i] = str.charCodeAt(i);
    }
    return bytes;
  }

  var v35 = function(name, version, hashfunc) {
    var generateUUID = function(value, namespace, buf, offset) {
      var off = buf && offset || 0;

      if (typeof(value) == 'string') value = stringToBytes(value);
      if (typeof(namespace) == 'string') namespace = uuidToBytes(namespace);

      if (!Array.isArray(value)) throw TypeError('value must be an array of bytes');
      if (!Array.isArray(namespace) || namespace.length !== 16) throw TypeError('namespace must be uuid string or an Array of 16 byte values');

      // Per 4.3
      var bytes = hashfunc(namespace.concat(value));
      bytes[6] = (bytes[6] & 0x0f) | version;
      bytes[8] = (bytes[8] & 0x3f) | 0x80;

      if (buf) {
        for (var idx = 0; idx < 16; ++idx) {
          buf[off+idx] = bytes[idx];
        }
      }

      return buf || bytesToUuid_1(bytes);
    };

    // Function#name is not settable on some platforms (#270)
    try {
      generateUUID.name = name;
    } catch (err) {
    }

    // Pre-defined namespaces, per Appendix C
    generateUUID.DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
    generateUUID.URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';

    return generateUUID;
  };

  // Adapted from Chris Veness' SHA1 code at

  function f(s, x, y, z) {
    switch (s) {
      case 0: return (x & y) ^ (~x & z);
      case 1: return x ^ y ^ z;
      case 2: return (x & y) ^ (x & z) ^ (y & z);
      case 3: return x ^ y ^ z;
    }
  }

  function ROTL(x, n) {
    return (x << n) | (x>>> (32 - n));
  }

  function sha1(bytes) {
    var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
    var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

    if (typeof(bytes) == 'string') {
      var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape
      bytes = new Array(msg.length);
      for (var i = 0; i < msg.length; i++) bytes[i] = msg.charCodeAt(i);
    }

    bytes.push(0x80);

    var l = bytes.length/4 + 2;
    var N = Math.ceil(l/16);
    var M = new Array(N);

    for (var i=0; i<N; i++) {
      M[i] = new Array(16);
      for (var j=0; j<16; j++) {
        M[i][j] =
          bytes[i * 64 + j * 4] << 24 |
          bytes[i * 64 + j * 4 + 1] << 16 |
          bytes[i * 64 + j * 4 + 2] << 8 |
          bytes[i * 64 + j * 4 + 3];
      }
    }

    M[N - 1][14] = ((bytes.length - 1) * 8) /
      Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14]);
    M[N - 1][15] = ((bytes.length - 1) * 8) & 0xffffffff;

    for (var i=0; i<N; i++) {
      var W = new Array(80);

      for (var t=0; t<16; t++) W[t] = M[i][t];
      for (var t=16; t<80; t++) {
        W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
      }

      var a = H[0];
      var b = H[1];
      var c = H[2];
      var d = H[3];
      var e = H[4];

      for (var t=0; t<80; t++) {
        var s = Math.floor(t/20);
        var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
        e = d;
        d = c;
        c = ROTL(b, 30) >>> 0;
        b = a;
        a = T;
      }

      H[0] = (H[0] + a) >>> 0;
      H[1] = (H[1] + b) >>> 0;
      H[2] = (H[2] + c) >>> 0;
      H[3] = (H[3] + d) >>> 0;
      H[4] = (H[4] + e) >>> 0;
    }

    return [
      H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff,
      H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff,
      H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff,
      H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff,
      H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff
    ];
  }

  var sha1Browser = sha1;

  var v5 = v35('v5', 0x50, sha1Browser);

  const {ETH_METHODS} = constants;

  /**
   * Builds the endpoint url to pass to .rawQuery(). Checks for non empties and appends
  the appropriate parameter(s) where applicable.
   *
   * @param web3data - Instance on which to call .rawQuery().
   * @param subendpoint - The sub-endpoint.
   * @param endpoint - The endpoint.
   * @param hash - The address hash.
   * @param pathParam - The path parameter.
   * @param filterOptions - The filters associated with a given endpoint.
   * @returns Returns a Promise of the rawQuery request from web3data.
   * @example
   */
  const get = (
    web3data,
    {
      endpoint = '',
      subendpoint = '',
      hash = '',
      pathParam = '',
      filterOptions = {}
    }
  ) => {
    const filters = is.nonEmptyObject(filterOptions)
      ? '?' + buildFilterUrl(filterOptions)
      : '';

    hash = hash ? '/' + hash : '';
    pathParam = pathParam ? '/' + pathParam : '';
    subendpoint = subendpoint ? '/' + subendpoint : '';
    return web3data.rawQuery(
      `${endpoint}${hash || pathParam}${subendpoint}${filters}`
    )
  };

  const buildFilterUrl = filterOptions => {
    let filterUrl = '';
    for (const filter in filterOptions) {
      if ({}.hasOwnProperty.call(filterOptions, filter)) {
        filterUrl += `${filter}=${filterOptions[filter]}&`;
      }
    }

    return filterUrl
  };

  const throwIf = (bool, message) => {
    if (bool) throw new Error(message)
  };

  const throwNow = message => throwIf(true, message);

  /**
   * Handler for all request responses.
   *
   * @param response - The Axios response object.
   * @returns The data from the response.
   * @private
   * @example
   */
  const onFulfilled = function(response) {
    throwIf(response.error, response.message);
    return this && this.formatter
      ? this.formatter(response.payload)
      : response.payload
  };

  const onError = ({response: {data}}) =>
    throwNow(data.message || data.description);

  const rejectPromiseIf = (condition, message) => {
    if (condition) return Promise.reject(new Error(message))
  };

  const is = () => {};
  is.string = value => typeof value === 'string';
  is.bool = value => typeof value === 'boolean';
  is.emptyString = value => is.string(value) && value.length === 0;
  is.emptyObject = object => Object.keys(object).length === 0;
  is.inObject = (object, property) =>
    Object.prototype.hasOwnProperty.call(object, property);
  is.undefined = value => typeof value === 'undefined';
  is.null = value => value === null;
  is.notHash = hash => is.undefined(hash) || is.emptyString(hash);
  is.notUndefined = value => !is.undefined(value);
  is.nonEmptyObject = object => !is.emptyObject(object);
  is.nonEmptyString = value => !is.emptyString(value);
  is.notInObject = (object, property) => !is.inObject(object, property);

  /**
   * Generates a uuid see [this gist]() for more details.
   *
   * @param data
   * @example
   */
  const uuid = data =>
    v5(JSON.stringify(data), 'ccfeca02-f0e9-4433-a740-b830cceb3d2d');

  /**
   * Returns an array of methods defined on the object.
   *
   * @param obj - The object from which get methods.
   * @returns An array of method names.
   * @private
   * @example
   */
  const getMethods = obj =>
    Object.getOwnPropertyNames(obj).filter(
      item => typeof obj[item] === 'function' && item !== 'constructor'
    );

  /**
   * Creates an object containing Ethereum based methods.
   *
   * @param web3data - { object } The web3data instance.
   * @returns methods { object } an object containing Ethereum based methods.
   * @private
   * @example
   */
  const ethFactory = function(web3data) {
    const methods = {};

    for (const method in ETH_METHODS) {
      /*  Assigns function bound to it's class instance
          Ex: getBlockNumber = web3data.block.getBlockNumber.bind(web3data.block) */
      if ({}.hasOwnProperty.call(ETH_METHODS, method)) {
        methods[method] = web3data[ETH_METHODS[method]][method].bind(
          web3data[ETH_METHODS[method]]
        );
      }
    }

    return methods
  };

  /**
   * Appends blockchain specific methods to an instance of Web3Data under it's
  correct namespacing.
   *
   * @param _this - Instance of Web3Data to append methods.
   * @param includeMethods
   * @private
   * @example
   */
  const methodFactory = (_this, includeMethods) => {
    Object.keys(includeMethods).forEach(namespace => {
      getMethods(Object.getPrototypeOf(_this.web3data[namespace])).forEach(
        method => {
          if (includeMethods[namespace].includes(method)) {
            _this[namespace] = _this[namespace] ? _this[namespace] : {};
            _this[namespace][method] = _this.web3data[namespace][method].bind(
              _this
            );
          }
        }
      );
    });
    return _this
  };

  /**
   * Creates a string in json rpc format.
   *
   * @param options - The json rpc options.
   * @returns The json rpc formatted string.
   * @private
   * @example
   *
   */
  const formatJsonRpc = options => {
    if (!options) return ''
    if (options.params) {
      options.params = Array.isArray(options.params)
        ? options.params
        : [options.params];
    }

    return JSON.stringify({
      jsonrpc: options.version || '2.0',
      method: options.method || 'subscribe',
      id: options.id || 0,
      params: options.params || []
    })
  };

  const defaultFormatter = (response, field) => {
    return response[field] ? response[field] : null
  };

  const recordsFormatter = response => defaultFormatter(response, 'records');

  var utils$1 = {
    buildFilterUrl,
    is,
    throwIf,
    get,
    rejectPromiseIf,
    uuid,
    ethFactory,
    methodFactory,
    throwNow,
    onFulfilled,
    onError,
    formatJsonRpc,
    getMethods,
    recordsFormatter
  };

  const {
    ERROR_MESSAGE_ADDRESS_NO_ADDRESS: NO_ADDRESS,
    ADDRESSES_ENDPOINT: ENDPOINT
  } = constants;

  const {
    is: is$1,
    get: get$1,
    throwIf: throwIf$1,
    onFulfilled: onFulfilled$1,
    onError: onError$1,
    recordsFormatter: recordsFormatter$1
  } = utils$1;

  /**
   * Contains methods pertaining to the `/address` endpoint of Amberdata's API.
   */
  class Address {
    /**
     * Creates an instance of Address.
     *
     * @param web3data - The web3data instance.
     * @example
     */
    constructor(web3data) {
      this.web3data = web3data;
    }

    /**
     * Alias of getAll().
     *
     * @param [filterOptions] - The filters associated with the request.
     * @example web3data.address.getAllAddresses({
     * size: 100,
     * })
     */
    getAllAddresses(filterOptions = {}) {
      return this.getAll(filterOptions)
    }

    /**
     * Returns every address that has been seen on the network.
     *
     * @param filterOptions - The filters associated with the request.
     * @param [filterOptions.hash] - Filter by a specific address.
     * @param [filterOptions.size] - The size of the response. <b>Default:</b> `100`.
     * @returns Containing an object with an array of objects containing. See [API docs](https://docs.amberdata.io/reference#get-all-addresses) for details on response.
     * @public
     * @example web3data.address.getAll({
     * size: 100,
     * })
     */
    getAll(filterOptions = {}) {
      return get$1(this.web3data, {endpoint: ENDPOINT, filterOptions}).then(
        onFulfilled$1.bind({formatter: recordsFormatter$1}),
        onError$1
      )
    }

    getInformation(hash, filterOptions) {
      if (is$1.notHash(hash)) return Promise.reject(new Error(NO_ADDRESS))
      return get$1(this.web3data, {
        hash,
        endpoint: ENDPOINT,
        subendpoint: 'information',
        filterOptions
      }).then(onFulfilled$1, onError$1)
    }

    getMetadata(hash, filterOptions) {
      throwIf$1(is$1.notHash(hash), NO_ADDRESS);
      return get$1(this.web3data, {
        hash,
        endpoint: ENDPOINT,
        subendpoint: 'metadata',
        filterOptions
      }).then(onFulfilled$1, onError$1)
    }

    getAdoption(hash, filterOptions) {
      if (is$1.notHash(hash)) return Promise.reject(new Error(NO_ADDRESS))
      return get$1(this.web3data, {
        hash,
        endpoint: ENDPOINT,
        subendpoint: 'adoption',
        filterOptions
      }).then(onFulfilled$1, onError$1)
    }

    /**
     * Retrieves the functions (aka internal messages) where this address is either the originator or a recipient.
     *
     * @param hash - The address of the account.
     * @param filterOptions - The filter options associated with the request.
     * @returns The balance data of the account or if no address is found.
     * @example
     */
    getInternalMessages(hash, filterOptions = {}) {
      return this.web3data.address.getFunctions(hash, filterOptions)
    }

    /**
     * Retrieves the functions (aka internal messages) where this address is either the originator or a recipient.
     *
     * @param hash - The address of the account.
     * @param filterOptions - The filter options associated with the request.
     * @returns The balance data of the account or if no address is found.
     * @example
     */
    getFunctions(hash, filterOptions = {}) {
      throwIf$1(is$1.notHash(hash), NO_ADDRESS);
      return get$1(this.web3data, {
        hash,
        endpoint: ENDPOINT,
        subendpoint: 'functions',
        filterOptions
      }).then(onFulfilled$1, onError$1)
    }

    /**
     * Retrieves the logs for the transactions where this address is either the originator or a recipient.
     *
     * @param hash - The address of the account.
     * @param filterOptions - The filter options associated with the request.
     * @returns Promise object containing the array of logs.
     * @public
     * @example web3data.getLogs('0x...')
     */
    getLogs(hash, filterOptions = {}) {
      throwIf$1(is$1.notHash(hash), NO_ADDRESS);
      return get$1(this.web3data, {
        hash,
        endpoint: ENDPOINT,
        subendpoint: 'logs',
        filterOptions
      }).then(onFulfilled$1, onError$1)
    }

    /**
     * Retrieves the transactions where this address was either the originator or a recipient.
     *
     * @param hash - The address of the account.
     * @param filterOptions - The filter options associated with the request.
     * @returns The object containing the array of transaction objects.
     * @example
     */
    getTransactions(hash, filterOptions = {}) {
      throwIf$1(!hash, NO_ADDRESS);
      return get$1(this.web3data, {
        hash,
        endpoint: ENDPOINT,
        subendpoint: 'transactions',
        filterOptions
      }).then(onFulfilled$1, onError$1)
    }

    /**
     * Retrieves pending transactions the specified address is involved in.
     *
     * @param hash - The address of the account.
     * @param filterOptions - The filter options associated with the request.
     * @returns The array of pending transactions.
     * @example
     */
    getPendingTransactions(hash, filterOptions = {}) {
      throwIf$1(!hash, NO_ADDRESS);
      return get$1(this.web3data, {
        hash,
        endpoint: ENDPOINT,
        subendpoint: 'pending-transactions',
        filterOptions
      }).then(onFulfilled$1, onError$1)
    }

    /**
     * Retrieves the latest or historical balance data of the given address depending upon
  Returns null if no address is found.
     *
     * @param hash - the address of the account
     * @param filterOptions - the filter options associated with the request
     * @returns the balance data of the account or if no address is found.
     * @example
     */
    getBalance(hash, filterOptions = {}) {
      throwIf$1(is$1.notHash(hash), NO_ADDRESS);
      return filterOptions.startDate || filterOptions.endDate
        ? this.web3data.address
            .getHistoricalBalance(hash, filterOptions)
            .then(data => data)
        : this.web3data.address
            .getLatestBalance(hash, filterOptions)
            .then(data => data)
    }

    /**
     * Retrieves the latest balance data of the given address. Returns null if no address is found.
     *
     * @param hash - The address of the account.
     * @param filterOptions - The filter options associated with the request.
     * @returns The balance data of the account or if no address is found.
     * @example
     */
    getLatestBalance(hash, filterOptions = {}) {
      throwIf$1(is$1.notHash(hash), NO_ADDRESS);
      return get$1(this.web3data, {
        hash,
        endpoint: ENDPOINT,
        subendpoint: 'account-balances/latest',
        filterOptions
      }).then(onFulfilled$1, onError$1)
    }

    /**
     * Retrieves the historical balance data of the given address. Returns null if no address is found.
     *
     * @param hash - The address of the account.
     * @param filterOptions - The filter options associated with the request.
     * @returns The historical balance data of the account or if no address is found.
     * @example
     */
    getHistoricalBalance(hash, filterOptions = {}) {
      throwIf$1(is$1.notHash(hash), NO_ADDRESS);
      return get$1(this.web3data, {
        hash,
        endpoint: ENDPOINT,
        subendpoint: 'account-balances/historical',
        filterOptions
      }).then(onFulfilled$1, onError$1)
    }

    /**
     * Retrieves the latest account and token balances for the specified address(es).
     *
     * @param hashes - The array or string containing the address(es) of the account.
     * @param filterOptions - The filter options associated with the request.
     * @returns The balance data of the account(s).
     * @example
     */
    getMultipleBalances(hashes, filterOptions = {}) {
      return Array.isArray(hashes)
        ? this.web3data.address.getBalancesBatch(hashes, filterOptions)
        : this.web3data.address.getBalances(hashes, filterOptions)
    }

    /**
     * Retrieves the latest account and token balances for the specified address.
     *
     * @param hash - The address of the account.
     * @param filterOptions - The filter options associated with the request.
     * @returns The balance data of the account.
     * @example
     */
    getBalances(hash, filterOptions = {}) {
      throwIf$1(is$1.notHash(hash), NO_ADDRESS);
      return get$1(this.web3data, {
        hash,
        endpoint: ENDPOINT,
        subendpoint: 'balances',
        filterOptions
      }).then(onFulfilled$1, onError$1)
    }

    /**
     * Retrieves the latest account and token balances for the specified addresses.
     *
     * @param hashes - The array containing the address(es) of the account.
     * @param filterOptions - The filter options associated with the request.
     * @returns The balance data of the account(s).
     * @example const await getBalancesBatch(['0x3f5ce5fbfe3e9af3971dd833d26ba9b5c936f0be', '0x06012c8cf97bead5deae237070f9587f8e7a266d'], {
     * includePrice: true
     * })
     */
    getBalancesBatch(hashes, filterOptions = {}) {
      throwIf$1(!Array.isArray(hashes), 'Must be array of valid address hashes');
      hashes.forEach(hash => throwIf$1(is$1.notHash(hash), NO_ADDRESS));
      filterOptions.addresses = hashes;
      return get$1(this.web3data, {
        endpoint: ENDPOINT,
        subendpoint: 'balances',
        filterOptions
      }).then(onFulfilled$1, onError$1)
    }

    /**
     * Retrieves the balance data of the given address. Returns null if no address is found.
     *
     * @param hash - The address of the account.
     * @param filterOptions - The filter options associated with the request.
     * @returns The token balance data of the account.
     * @example
     */
    getTokens(hash, filterOptions = {}) {
      throwIf$1(is$1.notHash(hash), NO_ADDRESS);
      return get$1(this.web3data, {
        hash,
        endpoint: ENDPOINT,
        subendpoint: 'tokens',
        filterOptions
      }).then(onFulfilled$1, onError$1)
    }

    /**
     * Retrieves all token transfers involving the specified address.
     *
     * @param hash - The address of the account.
     * @param filterOptions - The filter options associated with the request.
     * @returns The object containing the array of token transfer objects.
     * @example
     */
    getTokenTransfers(hash, filterOptions = {}) {
      throwIf$1(is$1.notHash(hash), NO_ADDRESS);
      return get$1(this.web3data, {
        hash,
        endpoint: ENDPOINT,
        subendpoint: 'token-transfers',
        filterOptions
      }).then(onFulfilled$1, onError$1)
    }

    getTokenBalances(hash, filterOptions) {
      if (is$1.notHash(hash)) return Promise.reject(new Error(NO_ADDRESS))
      return get$1(this.web3data, {
        hash,
        endpoint: ENDPOINT,
        subendpoint: 'token-balances',
        filterOptions
      }).then(onFulfilled$1, onError$1)
    }

    getUsage(hash, filterOptions) {
      if (is$1.notHash(hash)) return Promise.reject(new Error(NO_ADDRESS))
      return get$1(this.web3data, {
        hash,
        endpoint: ENDPOINT,
        subendpoint: 'usage',
        filterOptions
      }).then(onFulfilled$1, onError$1)
    }

    // TODO: Needs tests
    getMetrics(filterOptions) {
      return get$1(this.web3data, {
        endpoint: ENDPOINT,
        subendpoint: 'metrics/latest',
        filterOptions
      }).then(onFulfilled$1, onError$1)
    }
  }

  var address = Address;

  const {is: is$2, get: get$2, onFulfilled: onFulfilled$2, onError: onError$2} = utils$1;
  const {
    ERROR_MESSAGE_TOKEN_NO_ADDRESS: NO_ADDRESS$1,
    ERROR_MESSAGE_TOKEN_NO_HOLDER_ADDRESS: NO_HOLDER_ADDRESS,
    TOKENS_ENDPOINT: ENDPOINT$1
  } = constants;

  class Token {
    constructor(web3data) {
      this.web3data = web3data;
    }

    // TODO: Needs tests
    getRankings(filterOptions) {
      return get$2(this.web3data, {
        endpoint: ENDPOINT$1,
        subendpoint: 'rankings',
        filterOptions
      }).then(onFulfilled$2, onError$2)
    }

    getVolume(hash, filterOptions) {
      if (is$2.notHash(hash)) return Promise.reject(new Error(NO_ADDRESS$1))
      return get$2(this.web3data, {
        hash,
        endpoint: ENDPOINT$1,
        subendpoint: 'volume',
        filterOptions
      }).then(onFulfilled$2, onError$2)
    }

    getVelocity(hash, filterOptions) {
      if (is$2.notHash(hash)) return Promise.reject(new Error(NO_ADDRESS$1))
      return get$2(this.web3data, {
        hash,
        endpoint: ENDPOINT$1,
        subendpoint: 'velocity',
        filterOptions
      }).then(onFulfilled$2, onError$2)
    }

    getHolders(hash, filterOptions) {
      if (is$2.notHash(hash)) return Promise.reject(new Error(NO_ADDRESS$1))
      return get$2(this.web3data, {
        hash,
        endpoint: ENDPOINT$1,
        subendpoint: 'holders/latest',
        filterOptions
      }).then(onFulfilled$2, onError$2)
    }

    getHoldersHistorical(hash, filterOptions = {}) {
      if (is$2.notHash(hash)) return Promise.reject(new Error(NO_ADDRESS$1))
      if (is$2.notInObject(filterOptions, 'holderAddresses'))
        return Promise.reject(new Error(NO_HOLDER_ADDRESS))
      return get$2(this.web3data, {
        hash,
        endpoint: ENDPOINT$1,
        subendpoint: 'holders/historical',
        filterOptions
      }).then(onFulfilled$2, onError$2)
    }

    getSupplies(hash, filterOptions) {
      if (is$2.notHash(hash)) return Promise.reject(new Error(NO_ADDRESS$1))
      return get$2(this.web3data, {
        hash,
        endpoint: ENDPOINT$1,
        subendpoint: 'supplies/latest',
        filterOptions
      }).then(onFulfilled$2, onError$2)
    }

    getTransfers(hash, filterOptions) {
      if (is$2.notHash(hash)) return Promise.reject(new Error(NO_ADDRESS$1))
      return get$2(this.web3data, {
        hash,
        endpoint: ENDPOINT$1,
        subendpoint: 'transfers',
        filterOptions
      }).then(onFulfilled$2, onError$2)
    }
  }

  var token = Token;

  const {
    ERROR_MESSAGE_CONTRACT_NO_ADDRESS: NO_ADDRESS$2,
    CONTRACTS_ENDPOINT: ENDPOINT$2
  } = constants;
  const {is: is$3, get: get$3} = utils$1;

  class Contract {
    constructor(web3data) {
      this.web3data = web3data;
    }

    getDetails(hash, filterOptions) {
      if (is$3.notHash(hash)) return Promise.reject(new Error(NO_ADDRESS$2))
      return get$3(this.web3data, {
        pathParam: hash,
        endpoint: ENDPOINT$2,
        filterOptions
      })
    }

    getFunctions(hash, filterOptions) {
      if (is$3.notHash(hash)) return Promise.reject(new Error(NO_ADDRESS$2))
      return get$3(this.web3data, {
        pathParam: hash,
        endpoint: ENDPOINT$2,
        subendpoint: 'functions',
        filterOptions
      })
    }

    getAudit(hash, filterOptions) {
      if (is$3.notHash(hash)) return Promise.reject(new Error(NO_ADDRESS$2))
      return get$3(this.web3data, {
        pathParam: hash,
        endpoint: ENDPOINT$2,
        subendpoint: 'audit',
        filterOptions
      })
    }

    getAbi(hash, filterOptions) {
      if (is$3.notHash(hash)) return Promise.reject(new Error(NO_ADDRESS$2))
      return get$3(this.web3data, {
        pathParam: hash,
        endpoint: ENDPOINT$2,
        subendpoint: 'abi',
        filterOptions
      })
    }

    getSourceCode(hash, filterOptions) {
      if (is$3.notHash(hash)) return Promise.reject(new Error(NO_ADDRESS$2))
      return get$3(this.web3data, {
        pathParam: hash,
        endpoint: ENDPOINT$2,
        subendpoint: 'source-code',
        filterOptions
      })
    }

    async getCode(hash) {
      const response = await this.getDetails(hash);
      return new Promise((resolve, reject) => {
        if (
          is$3.null(response) ||
          is$3.undefined(response) ||
          response.status !== 200
        ) {
          reject(new Error('Failed to retrieve contract code.'));
        } else if (!response.payload) {
          reject(new Error('Failed to retrieve contract code.'));
        } else if (response.payload.bytecode) {
          resolve(response.payload.bytecode);
        } else {
          resolve('0x');
        }
      })
    }
  }

  var contract = Contract;

  const {
    TRANSACTIONS_ENDPOINT: ENDPOINT$3,
    ERROR_MESSAGE_TRANSACTION_NO_HASH: NO_HASH
  } = constants;

  const {is: is$4, get: get$4, onFulfilled: onFulfilled$3, onError: onError$3} = utils$1;

  class Transaction {
    constructor(web3data) {
      this.web3data = web3data;
    }

    async getTransactions(filterOptions) {
      const response = await get$4(this.web3data, {
        endpoint: ENDPOINT$3,
        filterOptions
      });
      return new Promise((resolve, reject) => {
        if (
          !response ||
          response.status !== 200 ||
          !response.payload ||
          !response.payload.records
        ) {
          reject(new Error('Failed to retrieve transactions.'));
        } else {
          resolve(response.payload.records);
        }
      })
    }

    async getTransaction(hash, filterOptions) {
      if (!hash) return Promise.reject(new Error(NO_HASH))
      const response = await get$4(this.web3data, {
        pathParam: hash,
        endpoint: ENDPOINT$3,
        filterOptions
      });
      return new Promise((resolve, reject) => {
        if (!response || response.status !== 200 || !response.payload) {
          reject(new Error('Failed to retrieve transaction.'));
        } else {
          resolve(response.payload);
        }
      })
    }

    async getPendingTransactions() {
      const pendingTransactions = await this.getTransactions({status: 'pending'});
      return new Promise((resolve, reject) => {
        if (is$4.undefined(pendingTransactions) || is$4.null(pendingTransactions)) {
          reject(new Error('Failed to retrieve pending transactions.'));
        } else {
          resolve(pendingTransactions);
        }
      })
    }

    getGasPrediction() {
      return get$4(this.web3data, {
        endpoint: ENDPOINT$3,
        subendpoint: 'gas/predictions'
      })
    }

    async getGasPrice() {
      const response = await this.getGasPrediction();
      return new Promise((resolve, reject) => {
        if (
          is$4.null(response) ||
          is$4.undefined(response) ||
          response.status !== 200
        ) {
          reject(new Error('Failed to retrieve gas price.'));
        } else if (!response.payload || !response.payload.average) {
          reject(new Error('Failed to retrieve gas price.'));
        } else {
          resolve(`${response.payload.average.gasPrice}`);
        }
      })
    }

    // TODO: Needs tests
    getVolume(filterOptions) {
      return get$4(this.web3data, {
        endpoint: ENDPOINT$3,
        subendpoint: 'volume',
        filterOptions
      }).then(onFulfilled$3, onError$3)
    }

    // TODO: Needs tests
    getMetrics(filterOptions) {
      return get$4(this.web3data, {
        endpoint: ENDPOINT$3,
        subendpoint: 'metrics/latest',
        filterOptions
      }).then(onFulfilled$3, onError$3)
    }
  }

  var transaction = Transaction;

  const {
    BLOCKS_ENDPOINT: ENDPOINT$4,
    ERROR_MESSAGE_BLOCK_NO_ID: NO_BLOCK_ID
  } = constants;

  const {
    is: is$5,
    get: get$5,
    throwIf: throwIf$2,
    onFulfilled: onFulfilled$4,
    onError: onError$4,
    recordsFormatter: recordsFormatter$2
  } = utils$1;

  class Block {
    constructor(web3data) {
      this.web3data = web3data;
    }

    // TODO: Needs tests
    getBlocks(filterOptions) {
      return get$5(this.web3data, {
        endpoint: ENDPOINT$4,
        filterOptions
      }).then(onFulfilled$4.bind({formatter: recordsFormatter$2}), onError$4)
    }

    /**
     * Retrieves the blocks specified by its id (number or hash).
     *
     * @param id - The number or hash of the block for which to retrieve block information.
     * @param [filterOptions] -
     * @returns
     * @example
     */
    getBlock(id, filterOptions) {
      throwIf$2(is$5.undefined(id), NO_BLOCK_ID);
      return get$5(this.web3data, {
        pathParam: id,
        endpoint: ENDPOINT$4,
        filterOptions
      }).then(onFulfilled$4, onError$4)
    }

    getBlockNumber() {
      return this.web3data.block.getBlock('latest').then(block => {
        throwIf$2(block | !block.number, 'Failed to retrieve block number.');
        return parseInt(block.number, 10)
      })
    }

    getBlockTransactionCount(id) {
      return this.web3data.block.getBlock(id).then(block => {
        throwIf$2(
          !block || (!block.predictions && !block.numTransactions),
          'Failed to retrieve block transaction count.'
        );
        // If 'predictions' field exists then it's a future block thus has no txns
        return block.predictions ? null : parseInt(block.numTransactions, 10)
      })
    }

    getTransactions(id, filterOptions) {
      throwIf$2(is$5.undefined(id), NO_BLOCK_ID);
      return get$5(this.web3data, {
        pathParam: id,
        endpoint: ENDPOINT$4,
        subendpoint: 'transactions',
        filterOptions
      }).then(onFulfilled$4.bind({formatter: recordsFormatter$2}), onError$4)
    }

    getTransactionFromBlock(id, index) {
      throwIf$2(is$5.undefined(id), NO_BLOCK_ID);
      return this.web3data.block.getTransactions(id).then(txns => {
        throwIf$2(!txns, 'Failed to retrieve transaction.');

        // Check that 'index' is within valid range
        return index < txns.length && index > -1 ? txns[index] : null
      })
    }

    getUncle(id, index) {
      throwIf$2(is$5.undefined(id), NO_BLOCK_ID);
      throwIf$2(is$5.undefined(index), "Missing required param 'index'");
      return this.web3data.block
        .getBlock(id, {
          validationMethod: 'full'
        })
        .then(block => {
          throwIf$2(
            !block ||
              (!block.predictions && !block.numTransactions && !block.validation),
            'Failed to retrieve uncle.'
          );
          // Check that it's...
          // a not a future block
          // and that the block has uncles
          // and 'index' is within the valid range
          return !block.predictions &&
            block.validation.uncles &&
            index < block.validation.uncles.length &&
            index > -1
            ? block.validation.uncles[index]
            : null
        })
    }

    getTokenTransfers(id, filterOptions) {
      throwIf$2(is$5.undefined(id), NO_BLOCK_ID);
      return get$5(this.web3data, {
        pathParam: id,
        endpoint: ENDPOINT$4,
        subendpoint: 'token-transfers',
        filterOptions
      }).then(onFulfilled$4, onError$4)
    }

    getLogs(id, filterOptions) {
      throwIf$2(is$5.undefined(id), NO_BLOCK_ID);
      return get$5(this.web3data, {
        pathParam: id,
        endpoint: ENDPOINT$4,
        subendpoint: 'logs',
        filterOptions
      }).then(onFulfilled$4.bind({formatter: recordsFormatter$2}), onError$4)
    }

    getFunctions(id, filterOptions) {
      throwIf$2(is$5.undefined(id), NO_BLOCK_ID);
      return get$5(this.web3data, {
        pathParam: id,
        endpoint: ENDPOINT$4,
        subendpoint: 'functions',
        filterOptions
      }).then(onFulfilled$4.bind({formatter: recordsFormatter$2}), onError$4)
    }

    getMetrics(filterOptions) {
      return get$5(this.web3data, {
        endpoint: ENDPOINT$4,
        subendpoint: 'metrics/latest',
        filterOptions
      }).then(onFulfilled$4, onError$4)
    }
  }

  var block = Block;

  const {get: get$6, is: is$6} = utils$1;
  const {
    SIGNATURES_ENDPOINT: ENDPOINT$5,
    ERROR_MESSAGE_SIGNATURE_NO_HASH: NO_HASH$1
  } = constants;

  class Signature {
    constructor(web3data) {
      this.web3data = web3data;
    }

    get4Byte(hash) {
      if (is$6.notHash(hash)) return Promise.reject(new Error(NO_HASH$1))
      return get$6(this.web3data, {hash, endpoint: ENDPOINT$5})
    }
  }

  var signature = Signature;

  const {is: is$7, get: get$7, throwIf: throwIf$3, onFulfilled: onFulfilled$5, onError: onError$5} = utils$1;
  const {
    MARKET_FEATURES: FEATURES,
    MARKET_ENDPOINT: ENDPOINT$6,
    ERROR_MESSAGE_MARKET_NO_PAIR: NO_MARKET_PAIR,
    ERROR_MESSAGE_MARKET_NO_FEATURE: NO_FEATURE
  } = constants;

  /**
   * Contains methods pertaining to the `/market` endpoint of Amberdata's API.
   */
  class Market {
    /**
     * Creates an instance of the Market class.
     *
     * @param web3data - The web3data instance.
     * @example
     */
    constructor(web3data) {
      this.web3data = web3data;
    }

    /**
     * Gets the current price of ether in USD.
     *
     * @returns Returns the price of ether price in USD.
     * @public
     * @example const etherPrice = web3data.market.getEtherPrice()
     */
    async getEtherPrice() {
      return get$7(this.web3data, {
        endpoint: ENDPOINT$6 + '/prices/eth/latest'
      }).then(response => response.payload.eth_usd.price, onError$5)
    }

    /**
     * Retrieves the top ranked assets by a specific metric.
     *
     * @param filterOptions - See [docs](https://docs.amberdata.io/reference#market-rankings) for complete list of filters.
     * @returns The market rankings data and total number of records.
     * @public
     * @example const rankings = web3data.market.getRankings({
     * type: "erc721",
     * sortType: "uniqueAddresses"
     * })
     */
    getRankings(filterOptions) {
      return get$7(this.web3data, {
        endpoint: ENDPOINT$6,
        subendpoint: 'rankings',
        filterOptions
      }).then(onFulfilled$5, onError$5)
    }

    /**
     * Retrieves the list of supported details by feature.
     *
     * @param features - The features for which to get supported details. Features: `pairs`, `exchanges`, `ohlcv`, `prices`, `tickers`.
     * @param [filterOptions] - The filter options.
     * @param [filterOptions.exchange] - Filter by exchange.
     * @param [filterOptions.pair filter] - By specific pairs.
     * @returns The list of supported details by feature.
     * @example // Single feature, filter by exchange
     * await web3data.market.getFeatures('pairs', {exchange: 'gdax'})
     *
     * // Multiple features, filter by pair
     * await web3data.market.getFeatures(['exchanges', 'tickers'], {pair: 'btc_usd'})
     */
    getFeatures(features = FEATURES, filterOptions = {}) {
      // Force feature to be array but allows non-array input
      features = Array.isArray(features) ? features : [features];

      // Iterate through each feature and if all is valid return array of promises
      features = features.map(feature => {
        // Check each feature that it is valid
        throwIf$3(is$7.undefined(feature) || !FEATURES.includes(feature), NO_FEATURE);

        // Append necessary url paths
        switch (feature) {
          case 'prices':
            feature += '/pairs';
            break
          case 'ohlcv':
          case 'tickers':
            feature += '/information';
            break
        }

        // Return a promise that retrieves the data from the server
        return (
          get$7(this.web3data, {
            endpoint: ENDPOINT$6,
            subendpoint: feature,
            filterOptions
          })
            .then(onFulfilled$5, onError$5)
            // Return an object with 'feature' as the key and response the value
            // .split('/')[0] removes the extra endpoint added above in switch
            .then(response => ({[feature.split('/')[0]]: response}))
        )
      });

      // Returns array of promises that once resolved are merged into a single object
      return Promise.all([...features]).then(data =>
        data.reduce((accumObj, curObj) => ({...accumObj, ...curObj}))
      )
    }

    /**
     * Retrieves the latest open-high-low-close for the specified pair.
     *
     * @param pair - The market pair for which to retrieve open-high-low-close.
     * @param [filterOptions] - See [docs](https://docs.amberdata.io/reference#get-historical-ohlc) for complete list of filters.
     * @returns The ohlcv data.
     * @public
     * @example // Latest
     * const latestOhlcv = await web3data.market.getOhlcv('eth_btc', {exchange: 'bitfinex'})
     *
     * // Historical (1 day ago)
     * const histOhlcv = await web3data.market.getOhlcv('btc_usd', {startDate: Math.round((Date.now() - 86400000) /1000)})
     */
    getOhlcv(pair, filterOptions = {}) {
      throwIf$3(is$7.undefined(pair), NO_MARKET_PAIR);
      const subendpoint =
        filterOptions.startDate || filterOptions.endDate ? 'historical' : 'latest';
      return get$7(this.web3data, {
        pathParam: pair,
        endpoint: `${ENDPOINT$6}/ohlcv`,
        subendpoint,
        filterOptions
      }).then(onFulfilled$5, onError$5)
    }

    /**
     * Retrieves the order book data for the specified pair.
     *
     * @param pair - The market pair for which to retrieve order book data.
     * @param exchange - The exchange(s) for which to retrieve order book data.
     * @param [filterOptions] - See [docs](https://docs.amberdata.io/reference#get-market-orders) for complete list of filters.
     * @returns The latest order book data for the specified pair/exchange(s).
     * @public
     * @example const orders = await web3data.market.getOrders('eth_usd', ['bitfinex', 'bitstamp'], {timeFormat: 'iso'})
     */
    getOrders(pair, exchange, filterOptions = {}) {
      throwIf$3(is$7.undefined(pair), NO_MARKET_PAIR);
      exchange = Array.isArray(exchange) ? exchange : [exchange];
      exchange.forEach(exchange =>
        throwIf$3(is$7.undefined(exchange), 'No exchange specified')
      );
      filterOptions.exchange = exchange;
      return get$7(this.web3data, {
        pathParam: pair,
        endpoint: `${ENDPOINT$6}/orders`,
        filterOptions
      }).then(onFulfilled$5, onError$5)
    }

    /**
     * Retrieves order book update events.
     *
     * @param pair - The market pair for which to retrieve the historical best bid and offer data.
     * @param [filterOptions] - See [docs](https://docs.amberdata.io/reference#order-book-updates) for complete list of filters.
     * @returns The order book update data.
     * @example const orderBooks = await web3data.market.getOrderBooks('btc_usd')
     */
    getOrderBooks(pair, filterOptions = {}) {
      throwIf$3(is$7.undefined(pair), NO_MARKET_PAIR);
      return get$7(this.web3data, {
        pathParam: pair,
        endpoint: `${ENDPOINT$6}/orders`,
        subendpoint: 'update',
        filterOptions
      }).then(onFulfilled$5, onError$5)
    }

    /**
     * Retrieves the latest or historical best bid and offer data for the specified pair and exchange (if specified).
     *
     * @param pair - The market pair for which to retrieve the latest best bid and offer data.
     * @param [filterOptions] - The filter options See [docs](https://docs.amberdata.io/reference#get-market-orders-best-bid-offer) for more details.
     * @param [filterOptions.exchange] - Only return data for the given exchanges (comma separated).
     * @param [filterOptions.pair] - Only return data for the given pairs (comma separated).
     * @param [filterOptions.startDate] - Filter by pairs after this date.
     * @param [filterOptions.endDate] - Filter by pairs before this date.
     * @returns The latest or historical best bid and offer data indexed by exchange.
     * @public
     * @example // Latest
     * const latestBbos = await web3data.market.getBbos('eth_btc')
     *
     * // Historical (1 day ago)
     * const histBbos = await web3data.market.getBbos('eth_btc', {startDate: Math.round((Date.now() - 86400000) /1000)})
     */
    getBbos(pair, filterOptions = {}) {
      throwIf$3(is$7.undefined(pair), NO_MARKET_PAIR);
      const subendpoint =
        filterOptions.startDate || filterOptions.endDate
          ? 'bbo/historical'
          : 'bbo';
      return get$7(this.web3data, {
        pathParam: pair,
        endpoint: `${ENDPOINT$6}/orders`,
        subendpoint,
        filterOptions
      }).then(onFulfilled$5, onError$5)
    }

    /**
     * Retrieves the historical prices for the specified asset.
     *
     * @param base - The base of a pair to retrieve the price. Example: If pair is "eth_usd", then base is "eth".
     * @param [filterOptions] - The filter options. See [docs](https://docs.amberdata.io/reference#market-prices-latest) for more details.
     * @returns The latest or historical market prices indexed by pair.
     * @example // Latest
     * const latestPrices = await web3data.market.getPrices('eth')
     *
     * // Historical (1 day ago)
     * const histPrices = await web3data.market.getPrices('eth', {startDate:  Math.round((Date.now() - 86400000) /1000)})
     */
    getPrices(base, filterOptions = {}) {
      throwIf$3(is$7.undefined(base), NO_MARKET_PAIR);
      const subendpoint =
        filterOptions.startDate || filterOptions.endDate ? 'historical' : 'latest';
      return get$7(this.web3data, {
        pathParam: base,
        endpoint: `${ENDPOINT$6}/prices`,
        subendpoint,
        filterOptions
      }).then(onFulfilled$5, onError$5)
    }

    // TODO: Needs tests
    // Returns supported details for each of our market endpoint data features
    getTokenPrices(hash, filterOptions = {}) {
      throwIf$3(is$7.notHash(hash), NO_MARKET_PAIR);
      const subendpoint =
        filterOptions.startDate || filterOptions.endDate ? 'historical' : 'latest';
      return get$7(this.web3data, {
        hash,
        endpoint: `${ENDPOINT$6}/tokens/prices`,
        subendpoint,
        filterOptions
      }).then(onFulfilled$5, onError$5)
    }

    /**
     * Retrieves the latest VWAP & TWAP price for the specified base.
     *
     * @param base - The base of a pair to retrieve the price. Example: If pair is "eth_usd", then base is "eth".
     * @param [filterOptions] - The filter options. See [docs](https://docs.amberdata.io/reference#get-current-vwaptwap-price) for more details.
     * @returns The latest VWAP & TWAP pricing data.
     * @example const wapData = await web3data.market.getVwap('eth', {quote: 'usd'})
     */
    getVwap(base, filterOptions = {}) {
      throwIf$3(is$7.undefined(base), NO_MARKET_PAIR);
      return get$7(this.web3data, {
        pathParam: base,
        endpoint: `${ENDPOINT$6}/prices`,
        subendpoint: 'wap/latest',
        filterOptions
      }).then(onFulfilled$5, onError$5)
    }

    /**
     * Retrieves the latest or historical market tickers.
     *
     * @param pair - The market pair for which to retrieve market tickers.
     * @param [filterOptions] - The filter options. See [docs](https://docs.amberdata.io/reference#get-current-vwaptwap-price) for more details.
     * @param [filterOptions.exchange] - Only return data for the given exchanges (comma separated).
     * @param [filterOptions.startDate] - Filter by ticker pairs after this date.
     * @param [filterOptions.endDate] - Filter by ticker pairs before this date.
     * @returns The latest or historical market ticker data.
     * @example //Latest
     * const latestTickers = await web3data.market.getTickers('eth_btc')
     *
     * //Historical
     * const histTickers = await web3data.market.getTickers('eth_btc', {startDate:  Date.now() - 86400000})
     */
    getTickers(pair, filterOptions = {}) {
      throwIf$3(is$7.undefined(pair), NO_MARKET_PAIR);
      const subendpoint =
        filterOptions.startDate || filterOptions.endDate ? 'historical' : 'latest';
      return get$7(this.web3data, {
        pathParam: pair,
        endpoint: `${ENDPOINT$6}/tickers`,
        subendpoint,
        filterOptions
      }).then(onFulfilled$5, onError$5)
    }

    /**
     * Retrieves the historical (time series) trade data for the specified pair.
     *
     * @param pair - The market pair for which to retrieve market trades.
     * @param [filterOptions] - The filter options. See [docs](https://docs.amberdata.io/reference#market-trades) for more details.
     * @returns The historical (time series) trade data.
     * @example const trades = web3data.market.getTrades('eth_usd', {exchange: 'bitstamp'})
     */
    getTrades(pair, filterOptions = {}) {
      throwIf$3(is$7.undefined(pair), NO_MARKET_PAIR);
      return get$7(this.web3data, {
        pathParam: pair,
        endpoint: `${ENDPOINT$6}/trades`,
        subendpoint: 'historical',
        filterOptions
      }).then(onFulfilled$5, onError$5)
    }

    /**
     * Retrieves the address on the blockchain (if available) of the specified asset.
     *
     * @param assets - The asset(s) to get the address of.
     * @returns The address(es) of the asset(s).
     * @example const batTokenAddress = web3data.market.getAssetAddresses('bat')
     * const assetAddresses = web3data.market.getAssetAddresses(['bat', 'rep'])
     */
    getAssetAddresses(assets = 'all') {
      return get$7(this.web3data, {
        endpoint: `${ENDPOINT$6}/pairs/addresses`,
        filterOptions: {symbols: assets}
      }).then(onFulfilled$5, onError$5)
    }
  }

  var market = Market;

  const {throwIf: throwIf$4, ethFactory: ethFactory$1} = utils$1;
  const {BLOCKCHAIN_ID_ETHEREUM_MAINNET: BLOCKCHAIN_ID} = constants;

  /**
   * Class for all Ethereum based methods.
   *
   * @private
   */
  class Eth {
    constructor(Web3data, apiKey, options) {
      options.blockchainId = BLOCKCHAIN_ID;
      this.web3data = new Web3data(apiKey, options);

      /* Get object containing eth specific methods */
      const methods = ethFactory$1(this.web3data);

      /* Defines the methods from above on the Eth instance */
      for (const method in methods) {
        if ({}.hasOwnProperty.call(methods, method)) {
          this[method] = methods[method];
        }
      }
    }

    /**
     * Returns the balance of the account in wei or null if the account doesn't
  exist.
     *
     * @param hash - The address of the account.
     * @returns Promise<object> - The balance or null if it doesn't exist.
     * @example
     */
    async getBalance(hash) {
      let balance;
      try {
        balance = await this.web3data.address.getBalance(hash);
      } catch (error) {
        throwIf$4(true, error.message);
      }

      return balance && balance.value ? balance.value : null
    }

    /* See Web3Data class for details on rpc method */
    rpc(method, params) {
      return this.web3data.rpc(method, params)
    }
  }

  var eth = Eth;

  const {
    BLOCKCHAIN_ID_BITCOIN: BLOCKCHAIN_ID$1,
    BTC_METHODS: METHODS
  } = constants;
  const {methodFactory: methodFactory$1} = utils$1;

  /**
   * Class for all Bitcoin based methods.
   *
   * @private
   */
  class Btc {
    constructor(Web3data, apiKey, options) {
      options.blockchainId = BLOCKCHAIN_ID$1;
      this.web3data = new Web3data(apiKey, options);
      methodFactory$1(this, METHODS);
    }

    /* See Web3Data class for details on rpc method */
    rpc(method, params) {
      return this.web3data.rpc(method, params)
    }
  }

  var btc = Btc;

  const {
    BLOCKCHAIN_ID_BITCOIN_CASH: BLOCKCHAIN_ID$2,
    BTC_METHODS: METHODS$1
  } = constants;
  const {methodFactory: methodFactory$2} = utils$1;

  /**
   * Class for all Bitcoin Cash based methods.
   *
   * @private
   */
  class Bch {
    constructor(Web3data, apiKey, options) {
      options.blockchainId = BLOCKCHAIN_ID$2;
      this.web3data = new Web3data(apiKey, options);
      methodFactory$2(this, METHODS$1);
    }

    /* See Web3Data class for details on rpc method */
    rpc(method, params) {
      return this.web3data.rpc(method, params)
    }
  }

  var bch = Bch;

  const {
    BLOCKCHAIN_ID_BITCOIN_SV: BLOCKCHAIN_ID$3,
    BTC_METHODS: METHODS$2
  } = constants;
  const {methodFactory: methodFactory$3} = utils$1;

  /**
   * Class for all Bitcoin SV based methods.
   *
   * @private
   */
  class Bsv {
    constructor(Web3data, apiKey, options) {
      options.blockchainId = BLOCKCHAIN_ID$3;
      this.web3data = new Web3data(apiKey, options);
      methodFactory$3(this, METHODS$2);
    }

    /* See Web3Data class for details on rpc method */
    rpc(method, params) {
      return this.web3data.rpc(method, params)
    }
  }

  var bsv = Bsv;

  const {
    BLOCKCHAIN_ID_LITECOIN: BLOCKCHAIN_ID$4,
    LTC_METHODS: METHODS$3
  } = constants;
  const {methodFactory: methodFactory$4} = utils$1;

  /**
   * Class for all Litecoin based methods.
   *
   * @private
   */
  class Ltc {
    constructor(Web3data, apiKey, options) {
      options.blockchainId = BLOCKCHAIN_ID$4;
      this.web3data = new Web3data(apiKey, options);
      methodFactory$4(this, METHODS$3);
    }

    /* See Web3Data class for details on rpc method */
    rpc(method, params) {
      return this.web3data.rpc(method, params)
    }
  }

  var ltc = Ltc;

  // https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js

  var ws = null;

  if (typeof WebSocket !== 'undefined') {
    ws = WebSocket;
  } else if (typeof MozWebSocket !== 'undefined') {
    ws = MozWebSocket;
  } else if (typeof commonjsGlobal !== 'undefined') {
    ws = commonjsGlobal.WebSocket || commonjsGlobal.MozWebSocket;
  } else if (typeof window !== 'undefined') {
    ws = window.WebSocket || window.MozWebSocket;
  } else if (typeof self !== 'undefined') {
    ws = self.WebSocket || self.MozWebSocket;
  }

  var browser$1 = ws;

  const {DEFAULT_WEBSOCKET_URL} = constants;
  const {is: is$8, uuid: uuid$1} = utils$1;

  /**
   * Creates a string in json rpc format.
   *
   * @param options - The json rpc options.
   * @returns The json rpc formatted string.
   * @private
   * @example
   */
  const formatJsonRpc$1 = options => {
    if (!options) return ''
    if (options.params) {
      options.params = Array.isArray(options.params)
        ? options.params
        : [options.params];
    }

    return JSON.stringify({
      jsonrpc: options.version || '2.0',
      method: options.method || 'subscribe',
      id: options.id || 0,
      params: options.params || []
    })
  };

  const RESPONSE_TYPE = {
    SUB_ACK: 0,
    DATA: 1,
    UNSUB_ACK: 2
  };

  /**
   * Returns enum corresponding to the response type.
   *
   * @param message - The response message from the server.
   * @returns The response type (see constants above).
   * @private
   * @example
   */
  const responseType = message => {
    if (message.params) {
      return RESPONSE_TYPE.DATA
    }

    if (is$8.string(message.result)) {
      return RESPONSE_TYPE.SUB_ACK
    }

    if (is$8.bool(message.result)) {
      return RESPONSE_TYPE.UNSUB_ACK
    }
  };

  const MAX_RECONNECTS = 3;
  const NO_DATA_TIMEOUT = 180000 * 10; // 30 minutes, give bitcoin some breathing room
  const NO_RESPONSE_TIMEOUT = 5000; // 5 seconds

  /**
   * Wrapper for Web3data websockets.
   */
  class WebSocketClient {
    /**
     * Instantiates the WebSocketClient.
     *
     * @param apiKey
     * @param options
     * @returns
     * @example
     */
    constructor(apiKey, options) {
      this.socket = null;
      this.baseWsUrl =
        options && options.websocketUrl
          ? options.websocketUrl
          : DEFAULT_WEBSOCKET_URL;
      this.apiKey = apiKey;
      this.blockchainId = null;

      // Internal state management
      this.connected = false;
      this.reconnects = 0;
      this.responseReceived = false;
      this.dataReceived = false;

      if (options.blockchainId) {
        this.blockchainId = options.blockchainId;
      }

      // Keep track of subscriptions, key/value mapping of subscription ID to listeners
      this.registry = {};

      // Key/value mapping of subscription ID to the uuid (hash) of subscription
      this.registrySubIds = {};

      // Keeps track of last data received by subscription key
      this.latestState = {};

      return this
    }

    /**
     * Connects to the websocket server and inits listeners.
     *
     * @param callBack - The method to call once connection process is complete.
     * @example
     */
    connect(callBack) {
      // Check if connected already, if so skip
      if (this.socket && this.socket.readyState === 1) return

      const apiKeyParam = this.apiKey ? `?x-api-key=${this.apiKey}` : '';
      const blockchainId = this.blockchainId
        ? `&x-amberdata-blockchain-id=${this.blockchainId}`
        : '';
      this.socket = new browser$1(
        `${this.baseWsUrl}${apiKeyParam}${blockchainId}`
      );

      // Initialize connection attempt
      this.socket.addEventListener('open', result => {
        console.info('websocket client connection opened');

        this.connected = true;

        // Send subscription messages if registered before connection est.
        this._refreshSubscriptions();

        // Bootstrap all the listeners now!
        this._listen();

        // Fire connected callback
        if (callBack) callBack(result);

        setTimeout(() => {
          if (
            !this.responseReceived &&
            is$8.nonEmptyObject(this.registry) &&
            this.socket
          )
            this.socket.close();
        }, NO_RESPONSE_TIMEOUT);

        setTimeout(() => {
          if (!this.dataReceived && is$8.nonEmptyObject(this.registry)) {
            this.socket.close();
          }
        }, NO_DATA_TIMEOUT);
      });

      this.socket.addEventListener('error', err => {
        if (callBack && err) {
          callBack('connection error occurred', err);
        } else {
          console.error('connection error occurred');
        }

        this._reconnect();
      });

      this.socket.addEventListener('close', data => {
        console.info('Websocket client connection closed - code', data.code);
        this._reconnect();
      });
    }

    /**
     * Destroys WebSocket i.e. Disconnects client and drops reference.
     *
     * @param callBack -The callback function that executes on close.
     * @example
     */
    disconnect(callBack = null) {
      if (this.socket && this.socket.readyState === 1) {
        this.socket.onclose = callBack
          ? () => callBack('Websocket client connection closed')
          : () => console.info('Websocket client connection closed');
        this.socket.close();
        this.socket = null;
      } else {
        console.error('socket is not yet connected');
      }
    }

    /**
     * Creates a new event listener for the specified event. Registers event and callback function.
     *
     * @param An - Object containing the event name and filters.
     * @config {string} eventName - The event for which to listen.
     * @config {object} filters - The extra arguments associated with the subscription.
     * @param callback - The callback function that executes when the
     * specified event is received by the websocket data listener.
     * @example
     */
    on({eventName, filters}, callback) {
      if (!callback) console.warn('no callback provided');
      if (!eventName) {
        console.error('no event specified');
        return
      }

      const id = uuid$1({eventName, filters});

      if (this.connected) {
        this._subscribe(eventName, filters);
      }

      this.registry[id] = {};
      this.registry[id].callback = callback;
      this.registry[id].args = {eventName, filters};
    }

    /**
     * Subscribes to the first occurrence of an event then unsubscribes.
     *
     * @param An - Object containing the event name and filters.
     * @config {string} eventName - The event for which to listen.
     * @config {object} filters - The extra arguments associated with the subscription.
     * @param callback - The callback function that executes when the
     * specified event is received by the websocket data listener.
     * @example
     */
    once({eventName, filters}, callback) {
      this.on({eventName, filters}, data => {
        this.off({eventName, filters}, () => {});
        if (callback) callback(data);

        // Kill the callback so that we don't stack em and call more than one
        this.registry[uuid$1({eventName, filters})].callback = null;
      });
    }

    /**
     * Destroys a single event listener. De-registers event and callback function.
     *
     * @param An - Object containing the event name and filters.
     * @config {string} eventName - The event to de-register.
     * @config {object} filters - The extra arguments associated with the subscription.
     * @param callback - The callback function to execute once unsubscribe is complete.
     * @example
     */
    off({eventName, filters}, callback) {
      if (!callback) console.warn('no callback provided');
      if (!eventName) {
        console.error('no event specified');
        return
      }

      const id = uuid$1({eventName, filters});
      if (!this.registry[id] || !this.registry[id].subId) {
        console.error(`Not subscribed to: '${eventName}'`);
        return
      }

      // Sends the unsubscribe message to the server
      this._unsubscribe(eventName, filters, id);
      this.registry[id].unsubCallback = callback;
    }

    /**
     * Initiates a reconnect given the following conditions:
  1. Initial connection doesnt respond within 5 seconds.
  2. Connection doesn't get any event within 3 minutes,
  and has at least 1 successful subscription.
  3. We got a socket error of any kind, see above.
     *
     * @private
     * @example
     */
    _reconnect() {
      if (this.socket.readyState === 1) {
        this.disconnect();
      }

      if (++this.reconnects <= MAX_RECONNECTS) {
        console.warn(
          `attempting to reconnect...${this.reconnects}/${MAX_RECONNECTS}`
        );
        this.connect();
      }
    }

    /**
     * Loops through each registry item and sends subscription message.
     *
     * @private
     * @example
     */
    _refreshSubscriptions() {
      if (!this.registry) return
      for (const {
        args: {eventName, filters}
      } of Object.values(this.registry)) {
        this._subscribe(eventName, filters);
      }
    }

    /**
     * Sets up the on message listener.
     *
     * @private
     * @example
     */
    _listen() {
      this.socket.addEventListener('message', message => {
        let data;
        try {
          data = JSON.parse(message.data);
        } catch (error) {
          console.error('error parsing json request -', error);
          return
        }

        this.responseReceived = true;

        switch (responseType(data)) {
          case RESPONSE_TYPE.SUB_ACK:
            this._subHandler(data);
            break
          case RESPONSE_TYPE.DATA:
            this._dataHandler(data);
            break
          case RESPONSE_TYPE.UNSUB_ACK:
            this._unsubHandler(data);
            break
        }
      });
    }

    /**
     * Handles subscription responses. Registers the server's
  given subscription Id.
     *
     * @param data - The parsed json data sent from the server.
     * @private
     * @example
     */
    _subHandler(data) {
      const id = data && data.id ? data.id : '';

      // Map the subscriptionId to the uuid
      this.registrySubIds[data.result] = id;
      this.registry[id].subId = data.result;
    }

    /**
     * Handles data responses. Calls registered callbacks.
     *
     * @param data - The parsed json data sent from the server.
     * @private
     * @example
     */
    _dataHandler(data) {
      this.dataReceived = true;

      const res =
        data && data.params && data.params.result ? data.params.result : {};
      const subId =
        data && data.params && data.params.subscription
          ? data.params.subscription
          : '';

      // Get the uuid
      const id = this.registrySubIds[subId];

      // Fire individual methods if they exist
      if (this.registry[id] && this.registry[id].callback)
        this.registry[id].callback(res);

      // Store latest state for easy retrieval later
      if (is$8.notUndefined(this.latestState[id])) this.latestState[id] = res;
      // This.reconnects = 0
    }

    /**
     * Handles the unsubscription response. Calls the unsubscribe call back registered in the off method then de-registers the event.
     *
     * @param data - The parsed json data sent from the server.
     * @private
     * @example
     */
    _unsubHandler(data) {
      const id = data && data.id ? data.id : '';
      const {eventName} = this.registry[id].args;
      if (data.result) {
        this.registry[id].unsubCallback(
          `successfully unsubscribed from - ${eventName}`
        );
        delete this.registry[id];
      } else {
        this.registry[id].unsubCallback(
          `Error: Not unsubscribed from - ${eventName}`
        );
      }
    }

    /**
     * Sends subscription message to the websocket connection.
     *
     * @param eventName - The name of the event to subscribe to.
     * @param filters - The extra arguments associated with the subscription.
     * @private
     * @example
     */
    _subscribe(eventName, filters) {
      const params = is$8.notUndefined(filters) ? [filters] : [];
      const id = uuid$1({eventName, filters});
      const jsonRpcMessage = formatJsonRpc$1({id, params: [eventName, ...params]});
      this.socket.send(jsonRpcMessage);
    }

    /**
     * Sends unsubscription message to the websocket connection.
     *
     * @param eventName - The name of the event to unsubscribe from.
     * @param filters - The extra arguments associated with the subscription.
     * @param id - The derived uuid.
     * @private
     * @example
     */
    _unsubscribe(eventName, filters, id) {
      const jsonRpcMessage = formatJsonRpc$1({
        id,
        method: 'unsubscribe',
        params: [this.registry[id].subId]
      });

      if (this.socket.readyState === this.socket.OPEN)
        this.socket.send(jsonRpcMessage);
    }
  }

  var websocket = WebSocketClient;

  const {
    API_KEY_HEADER,
    BLOCKCHAIN_ID_HEADER,
    DEFAULT_BASE_URL,
    DEFAULT_RPC_URL,
    ERROR_RPC_NO_METHOD
  } = constants;
  const {is: is$9, throwIf: throwIf$5, formatJsonRpc: formatJsonRpc$2} = utils$1;














  /**
   * Contains common methods used in.
   */
  class Web3DataFactory {
    /**
     * Creates a Web3Data instance.
     *
     * @param apiKey - The Amberdata api key needed to access data.
     * @param {object} options Contains additional configuration options:
     * @param blockchainId: specifies the blockchain to get data from
     * @param - baseUrl: the base url of API calls
     * @param - websocketUrl: the websocket url to use
     * @example
     */
    constructor(apiKey, options = {}) {
      throwIf$5(
        is$9.undefined(apiKey) || is$9.emptyString(apiKey),
        'No api key supplied'
      );

      this.apiKey = apiKey;
      this.blockchainId = null;

      /* Setup required request headers */
      this.headers = {};
      this.headers[API_KEY_HEADER] = this.apiKey;

      /* Setup optional request headers */
      if (options.blockchainId) {
        this.blockchainId = options.blockchainId;
        this.headers[BLOCKCHAIN_ID_HEADER] = options.blockchainId;
      }

      this.wsConfig = {
        ...options,
        websocketUrl: options.websocketUrl ? options.websocketUrl : null
      };

      this.baseUrl = options.baseUrl ? options.baseUrl : DEFAULT_BASE_URL;

      /* Web3Data composite modules */
      this.address = new address(this);
      this.token = new token(this);
      this.contract = new contract(this);
      this.transaction = new transaction(this);
      this.block = new block(this);
      this.signature = new signature(this);
      this.market = new market(this);
    }

    /**
     * Appends the API base url with the endpoint  url. Then sends an
  http request to the Amberdata API endpoint.
     *
     * @param url - The endpoint url with any query/path params if set.
     * @returns The axios request object.
     * @example
     */
    rawQuery(url) {
      return axios$1
        .get(this.baseUrl + url, {
          headers: this.headers
        })
        .then(r => r.data)
    }

    /**
     * Method used to interact with web3api json rpc endpoints.
     *
     * @param method - The json rpc method to call.
     * @param params - The parameters to the json rpc call.
     * @returns Returns the json rpc result.
     * @example
     */
    rpc(method, params = []) {
      throwIf$5(!method, ERROR_RPC_NO_METHOD);
      return axios$1
        .post(
          `${DEFAULT_RPC_URL}?${API_KEY_HEADER}=${this.apiKey}&${BLOCKCHAIN_ID_HEADER}=${this.blockchainId}`,
          formatJsonRpc$2({method, params}),
          {
            headers: this.headers
          }
        )
        .then(response => response.data, response => response.response.data)
    }
  }

  /**
   * Class Web3data contains methods for hitting Amberdata's
   * API endpoints.
   * */
  class Web3Data extends Web3DataFactory {
    constructor(apiKey, options = {}) {
      super(apiKey, options);

      /* Instantiates a new Web3data.js instance with blockchain specific methods */
      this.eth = new eth(Web3DataFactory, apiKey, options);
      this.btc = new btc(Web3DataFactory, apiKey, options);
      this.bch = new bch(Web3DataFactory, apiKey, options);
      this.bsv = new bsv(Web3DataFactory, apiKey, options);
      this.ltc = new ltc(Web3DataFactory, apiKey, options);

      this.websocket = null;
    }

    connect(callback) {
      this.websocket = this.websocket
        ? this.websocket
        : new websocket(this.apiKey, this.wsConfig);
      return this.websocket.connect(callback)
    }

    disconnect(callback) {
      if (this.websocket) {
        this.websocket.disconnect(callback);
      } else {
        console.error('socket is not yet connected');
      }
    }

    on({eventName, filters}, callback) {
      if (!callback) console.warn('no callback provided');
      if (!eventName) {
        console.error('no event specified');
        return
      }

      this.websocket.on({eventName, filters}, callback);
    }

    once({eventName, filters}, callback) {
      this.websocket.once({eventName, filters}, callback);
    }

    off({eventName, filters}, callback) {
      if (!callback) console.warn('no callback provided');
      if (!eventName) {
        console.error('no event specified');
        return
      }

      this.websocket.off({eventName, filters}, callback);
    }
  }

  var web3data = Web3Data;

  // eslint-disable-next-line no-undef
  if (typeof window !== 'undefined' && typeof window.Web3Data === 'undefined') {
    window.Web3Data = web3data; // eslint-disable-line no-undef
  }

  var web3dataJs = web3data;

  return web3dataJs;

})));
